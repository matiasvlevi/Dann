const isBrowser="object"!=typeof process,VERSION="v2.2.11";function bitLength(t){return t<1?1:Math.floor(Math.log(t)/Math.log(2))+1}function numberToBinary(t,e){let i=t.toString(2),r=[],n=bitLength(t)-1;for(let t=e-1;t>=0;t--){let e=i.charAt(n);r[t]=""===e?0:JSON.parse(e),n--}return r}function makeBinary(t,e){let i;i=void 0!==e?e:function(t){return t+1};let r=[];for(let e=0;e<Math.pow(2,t)-1;e++){let n=i(e);if(bitLength(n)<=t){let i={input:numberToBinary(e,t),output:numberToBinary(n,t)};r.push(i)}}return r}function makeSinWave(t,e,i){let r=[];for(let n=0;n<t*e*i;n+=i)r.push(Math.sin(n));r.length===t*e+1&&r.splice(r.length-1,1);let n=[];for(let i=0;i<e;i++)n.push(r.slice(i*t,i*t+t));return n}function makeXOR(t){if(t<2)return[];let e=makeBinary(t),i={input:e[e.length-1].output,output:[]};return e.push(i),e.forEach((t=>{delete t.output,t.output=[t.input.reduce(((t,e)=>t+e),0)%2]})),e}Add=function(){},Add.activation=function(t,e,i){if("string"==typeof t)return 1!==e.length||1!==i.length?void DannError.error("One of the functions specified does not have only 1 argument.","Add.activation"):(activations[t]=e,void(activations[t+"_d"]=i));DannError.error("The name argument is not a string.","Add.activation")},Add.loss=function(t,e){"string"==typeof t?2===e.length?lossfuncs[t]=e:DannError.error("The loss function specified can only have 2 argument.","newActivation"):DannError.error("The name argument is not a string.","Add.loss")};const XOR=makeXOR(2);function sigmoid(t){return 1/(1+Math.exp(-t))}function sigmoid_d(t){let e=sigmoid(t);return e*(1-e)}function leakySigmoid(t){return 1/(1+Math.exp(-t))+t/100}function leakySigmoid_d(t){let e=leakySigmoid(t);return e*(1-e)}function siLU(t){return t/(1+Math.exp(-t))}function siLU_d(t){return(1+Math.exp(-t)+t*Math.exp(-t))/Math.pow(1+Math.exp(-t),2)}function tanH(t){return(Math.exp(t)-Math.exp(-t))/(Math.exp(t)+Math.exp(-t))}function tanH_d(t){return 1-Math.pow(tanH(t),2)}function leakyReLUCapped(t){return t>=0&&t<=6?t:t<0?.1*t:6}function leakyReLUCapped_d(t){return t>=0&&t<=6?1:t<0?.1:0}function leakyReLU(t){return t>=0?1*t:.01*t}function leakyReLU_d(t){return t>=0?1:.01}function reLU(t){return t>=0?1*t:0}function reLU_d(t){return t>=0?1:0}function sinc(t){return 0===t?1:Math.sin(t)/t}function sinc_d(t){return 0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t)}function softsign(t){return t/(1+Math.abs(t))}function softsign_d(t){let e=1+Math.abs(t);return 1/(e*e)}function binary(t){return t<=0?0:1}function binary_d(t){return 0}function softplus(t){return Math.log(1+Math.exp(t))}function softplus_d(t){return sigmoid(t)}DannError=function(t,e){this.msg=t,this.method=e},DannError.prototype.warn=function(){isBrowser?(console.error("DannWarning: "+this.msg),console.error("> "+this.method)):(console.error("[33mDannWarning: "+this.msg+"[0m"),console.error("[33m> "+this.method+"[0m")),console.trace()},DannError.prototype.error=function(){isBrowser?(console.warn("DannError: "+this.msg),console.warn("> "+this.method)):(console.warn("[31mDannError: "+this.msg+"[0m"),console.warn("[31m> "+this.method+"[0m")),console.trace()},DannError.warn=function(t,e){isBrowser?(console.warn("DannWarning: "+t),console.warn("> "+e)):(console.warn("[33mDannWarning: "+t+"[0m"),console.warn("[33m> "+e+"[0m")),console.trace()},DannError.error=function(t,e){isBrowser?(console.error("DannError: "+t),console.error("> "+e)):(console.error("[31mDannError: "+t+"[0m"),console.error("[31m> "+e+"[0m")),console.trace()};let activations={sigmoid:sigmoid,sigmoid_d:sigmoid_d,tanH:tanH,tanH_d:tanH_d,siLU:siLU,siLU_d:siLU_d,reLU:reLU,reLU_d:reLU_d,leakyReLU:leakyReLU,leakyReLU_d:leakyReLU_d,sinc:sinc,sinc_d:sinc_d,softsign:softsign,softsign_d:softsign_d,binary:binary,binary_d:binary_d,softplus:softplus,softplus_d:softplus_d,leakySigmoid:leakySigmoid,leakySigmoid_d:leakySigmoid_d,leakyReLUCapped:leakyReLUCapped,leakyReLUCapped_d:leakyReLUCapped_d};function mae(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){let n=e[r],o=t[r];i+=abs(n-o)}return r=i/n,r}function bce(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){let n=e[r],o=t[r];i+=n*log(o)+(1-n)*log(1-o)}return r=-i/n,r}function lcl(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){let n=e[r],o=t[r];i+=log(cosh(o-n))}return r=i/n,r}function mbe(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){i+=e[r]-t[r]}return r=i/n,r}function mael(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){let n=e[r]-t[r];i+=-n*(exp(-n)-1)/(exp(-n)+1)}return r=i/n,r}function rmse(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){let n=e[r],o=t[r];i+=pow(n-o,2)}return r=sqrt(i/n),r}function mce(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){let n=e[r],o=t[r];i+=pow(abs(n-o),3)}return r=i/n,r}function mse(t,e){let i=0,r=0,n=e.length;for(let r=0;r<n;r++){let n=e[r],o=t[r];i+=pow(n-o,2)}return r=i/n,r}function quantile(t,e,i){let r=i,n=0;for(let i=0;i<e.length;i++)e[i]-t[i]>=0?n+=r*(e[i]-t[i]):n+=(r-1)*(e[i]-t[i]);return n/e.length}let lossfuncs={mae:mae,bce:bce,lcl:lcl,mbe:mbe,mce:mce,mse:mse,rmse:rmse,mael:mael,quantile:quantile};const random=(t,e)=>Math.random(1)*(e-t)+t,exp=t=>Math.exp(t),abs=t=>Math.abs(t),log=t=>Math.log(t),pow=(t,e)=>Math.pow(t,e),round=t=>Math.round(t),sqrt=t=>Math.sqrt(t),cosh=t=>(exp(t)+exp(-t))/2;let poolfuncs={max:function(t){let e=0,i=t.length;for(let r=0;r<i;r++)t[r]>e&&(e=t[r]);return e},min:function(t){let e=1/0,i=t.length;for(let r=0;r<i;r++)t[r]<e&&(e=t[r]);return e},avg:function(t){let e=0,i=t.length;for(let r=0;r<i;r++)e+=t[r];return e/i}};Matrix=function(t=0,e=0){this.rows=t,this.cols=e,this.shape="( "+this.rows+" , "+this.cols+" )";let i=[[]];for(let r=0;r<t;r++){i[r]=[];for(let t=0;t<e;t++)i[r][t]=0}this.matrix=i},Matrix.prototype.add=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.add");for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]+=t.matrix[e][i];return this}for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]+=t;return this},Matrix.add=function(t,e){let i=new Matrix(t.rows,t.cols);if(t.rows===e.rows&&t.cols===e.cols){for(let r=0;r<i.rows;r++)for(let n=0;n<i.cols;n++)i.matrix[r][n]=t.matrix[r][n]+e.matrix[r][n];return i}DannError.error("Matrix dimensions should match","Matrix.add")},Matrix.addGrid=function(t,e){let i=t.matrix,r=e.matrix,n=[];for(let t=0;t<i[0].length;t++){n[t]=[];for(let e=0;e<i[0].length;e++)n[t].push(i[0][t]+r[e][0])}return(new Matrix).set(n)},Matrix.addColumn=function(t,e){let i,r;1===t.cols?(i=t,r=e):1===e.cols&&(i=e,r=t);let n=new Matrix(r.rows,r.cols);for(let t=0;t<r.rows;t++)for(let e=0;e<r.cols;e++)n.matrix[t][e]=r.matrix[t][e]+i.matrix[t][0];return n},Matrix.prototype.addPercent=function(t){for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];this.matrix[e][i]+=r*t}},Matrix.prototype.addRandom=function(t,e){let i=Matrix.make(this.rows,this.cols);if(e<=0||e>1)DannError.error("Probability argument must be between 0 and 1","Matrix.prototype.addRandom");else for(let r=0;r<this.rows;r++)for(let n=0;n<this.cols;n++){let o=this.matrix[r][n];random(0,1)<e&&(i[r][n]=o+o*random(-t,t))}this.set(i)},Matrix.fromArray=function(t,e){let i=!1;void 0!==e&&(i=e.flip);let r=new Matrix(t.length,1);for(let e=0;e<t.length;e++)!1===i?r.matrix[e][0]=t[e]:!0===i&&(r.matrix[0][e]=t[e]);return r},Matrix.prototype.initiate=function(t=0){if(void 0===t);else{if("number"==typeof t){for(let e=0;e<this.matrix.length;e++)for(let i=0;i<this.matrix[e].length;i++)this.matrix[e][i]=t;return this}DannError.error("The value entered as an argument is not a number","Matrix.prototype.initiate")}},Matrix.prototype.insert=function(t,e,i){if("number"==typeof t)if("number"==typeof e){if("number"==typeof i)return e<this.rows&&i<this.cols?(this.matrix[e][i]=t,this):void DannError.error(" x, y arguments exceed the matrix dimensions.","Matrix.prototype.insert");DannError.error('Expected Number for "y" argument',"Matrix.prototype.insert")}else DannError.error('Expected Number for "x" argument',"Matrix.prototype.insert");else DannError.error('Expected Number for "value" argument',"Matrix.prototype.insert")},Matrix.prototype.log=function(t){let e=!1;void 0!==t&&t.table&&(e=t.table),e?console.table(this.matrix):console.log(this)},Matrix.make=function(t=0,e=0){let i=[[]];for(let r=0;r<t;r++){i[r]=[];for(let t=0;t<e;t++)i[r][t]=0}return i},Matrix.prototype.makeShape=function(){return"( "+this.rows+" , "+this.cols+" )"},Matrix.prototype.map=function(t){if("function"==typeof t){for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];this.matrix[e][i]=t(r)}return this}DannError.error("Argument must be a function","Matrix.prototype.map")},Matrix.map=function(t,e){if(t instanceof Matrix){let i=new Matrix(t.rows,t.cols);for(let r=0;r<t.rows;r++)for(let n=0;n<t.cols;n++){let o=t.matrix[r][n];i.matrix[r][n]=e(o)}return i}DannError.error("First argument must be an instance of Matrix","Matrix.map")},Matrix.prototype.max=function(){let t=0;for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];t<r&&(t=r)}return t},Matrix.prototype.min=function(){let t=1e10;for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];t>r&&(t=r)}return t},Matrix.prototype.mult=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("The matrix dimensions should match in order to multiply their values. If you are looking for dot product, try Matrix.mult","Matrix.prototype.mult");for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]*=t.matrix[e][i];return this}for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]*=t;return this},Matrix.mult=function(t,e,i={mode:"cpu"}){if(void 0!==i&&i.mode&&(mode=i.mode),"cpu"===mode){let i=new Matrix(t.rows,e.cols);if(t instanceof Matrix&&e instanceof Matrix){if(t.cols!==e.rows)return void DannError.error("The rows of B must match the columns of A","Matrix.mult");for(let r=0;r<i.rows;r++)for(let n=0;n<i.cols;n++){let o=0;for(let i=0;i<t.cols;i++)o+=t.matrix[r][i]*e.matrix[i][n];i.matrix[r][n]=o}return i}}else DannError.error("mode specified is not valid","Matrix.prototype.mult")},Matrix.prototype.randomize=function(t,e){for(let i=0;i<this.matrix.length;i++)for(let r=0;r<this.matrix[i].length;r++)this.matrix[i][r]=random(t,e);return this},Matrix.prototype.set=function(t){return"number"==typeof t.length&&"number"==typeof t[0].length&&"object"==typeof t?(this.matrix=t,this.rows=t.length,this.cols=t[0].length,this.shape=this.makeShape(),this):void DannError.error("the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]","Matrix.prototype.set")},Matrix.prototype.sub=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.sub");for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]-=t.matrix[e][i];return this}for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]-=t;return this},Matrix.sub=function(t,e){if(t instanceof Matrix&&e instanceof Matrix){if(t.rows!==e.rows||t.cols!==e.cols)return void DannError.error("The matrix dimensions should match","Matrix.sub");{let i=new Matrix(t.rows,t.cols);for(let r=0;r<i.rows;r++)for(let n=0;n<i.cols;n++)i.matrix[r][n]=t.matrix[r][n]-e.matrix[r][n];return i}}DannError.error("The arguments should be Matrices","Matrix.sub")},Matrix.prototype.toArray=function(){let t=[];if(1===this.cols){for(let e=0;e<this.rows;e++)t[e]=this.matrix[e][0];return t}return 1===this.rows?(t=this.matrix[0],t):void DannError.error("None of the lengths of the matrix equal 1","Matrix.prototype.toArray")},Matrix.toArray=function(t){let e=[];if(1===t.cols){for(let i=0;i<t.rows;i++)e[i]=t.matrix[i][0];return e}return 1===t.rows?(e=t.matrix[0],e):void DannError.error("None of the lengths of the matrix equal 1","Matrix.toArray")},Matrix.transpose=function(t){let e=new Matrix(t.cols,t.rows);for(let i=0;i<t.rows;i++)for(let r=0;r<t.cols;r++)e.matrix[r][i]=t.matrix[i][r];return e},Layer=function t(e,i,r,n,o,s){if(this.type=e,this.subtype=this.getSubtype(),"pool"!==this.subtype)"hidden"===this.type||"output"===this.type?(this.size=i,this.setFunc(r),this.layer=new Matrix(this.size,1)):"input"===this.type&&(this.size=i,this.layer=new Matrix(this.size,1));else if("pool"===this.subtype){if(this.stride=n,this.sampleSize=r,this.inputSize=i,void 0!==o&&void 0!==s)this.sizeX=o,this.sizeY=s;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=t.getPoolOutputLength(r,n,this.sizeX,this.sizeY);let e=this.inputSize/this.sizeX,a=this.inputSize/this.sizeY;if(e!==Math.floor(e)&&a!==Math.floor(a))return console.error("Dann Error: the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)"),void console.trace();if(this.size!==Math.floor(this.size))return console.error("Dann Error: the Width must be divisible by the stride (jumps size). Width is the root of the array's length."),void console.trace();this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1),this.prefix=this.getPrefix(),this.poolfunc=poolfuncs[this.prefix],this.downsample=function(e,i,r){this.input=Matrix.fromArray(e);let n=t.selectPools(e,i,r,this.sizeX,this.sizeY),o=[];for(let t=0;t<n.length;t++)o[t]=this.poolfunc(n[t]);return this.layer=Matrix.fromArray(o),o}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())},Layer.prototype.feed=function(t,e){if("pool"===this.subtype){let i=!1,r=!1,n=this.sampleSize,o=this.stride;if(void 0!==e&&(e.log&&(i=e.log),e.table&&(r=e.table)),t.length!==this.inputSize)return void DannError.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has.","Layer.prototype.feed");{let e=this.downsample(t,n,o);return i&&(r?console.table(e):console.log(e)),e}}DannError.error("This function can only be used by Layers with 'pool' subtype","Layer.prototype.feed")},Layer.getPoolOutputLength=function(t,e,i,r){return((i-t)/e+1)*((r-t)/e+1)},Layer.getSqIndex=function(t,e,i){return t*i+e},Layer.prototype.log=function(){console.log(this)},Layer.selectPools=function(t,e,i,r,n){t.length;if(r!==Math.floor(r))return;if(r/i!==Math.floor(r/i))return;let o=[];for(let s=0;s+e<=n;s+=i)for(let n=0;n+e<=r;n+=i){let i=[];for(let o=0;o<e;o++)for(let a=0;a<e;a++)i.push(t[Layer.getSqIndex(r,a+n,o+s)]);o.push(i)}return o},Layer.prototype.setFunc=function(t){let e=Layer.stringTofunc(t);void 0!==e?(this.actname=e.name,this.actname_d=e.name_d,this.actfunc=e.func,this.actfunc_d=e.func_d):DannError.error("Bad activation information","Layer.prototype.setFunc")},Layer.stringTofunc=function(t){let e,i,r=t,n=r+"_d";return e=activations[r],i=activations[n],void 0!==e?void 0!==i?{name:r,name_d:n,func:e,func_d:i}:void DannError.error("Dann Error: You need to create the derivative of your custom function. The activation function specified '"+t+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc"):void DannError.error("Dann Error: the activation function '"+t+"' is not a valid activation function. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc")},Layer.prototype.getPrefix=function(){let t=this.type,e=t.length;return t.slice(0,e-4)},Layer.prototype.getSubtype=function(){let t=this.type,e=t.length,i=t.slice(e-4,e);return"pool"===i?i:t},Rann=function(t=2,e=8,i=2){this.i=t,this.o=i,this.h=e,this.lr=.001,this.arch=[this.i,this.h,this.o],this.layers=[],this.U=new Matrix(this.h,this.i),this.V=new Matrix(this.o,this.h),this.W=new Matrix(this.h,this.h),this.dU=new Matrix(this.h,this.i),this.dV=new Matrix(this.o,this.h),this.dW=new Matrix(this.h,this.h),this.dU_t=new Matrix(this.h,this.i),this.dV_t=new Matrix(this.o,this.h),this.dW_t=new Matrix(this.h,this.h),this.dU_i=new Matrix(this.h,this.i),this.dW_i=new Matrix(this.h,this.h),this.U.randomize(-1,1),this.V.randomize(-1,1),this.W.randomize(-1,1),this.mulv,this.mulw,this.mulu,this.actname="sigmoid";let r=Layer.stringTofunc(this.actname);this.actfunc=r.func,this.actfunc_d=r.func_d,this.o_actname="linear",this.o_actfunc=t=>t,this.o_actfunc_d=t=>1,this.previous,this.input,this.output,this.normalize=!1,this.largestSequenceValue=1,this.truncate=5,this.loss=100,this.epoch=0,this.lossfunc_s="mse",this.lossfunc=lossfuncs[this.lossfunc_s]},Rann.ascii=function(){return" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"},Rann.asciiToBinary=function(t){return numberToBinary(Rann.ascii().indexOf(t),7)},Rann.binaryToAscii=function(t){let e=Rann.ascii(),i=t.toString().replace(/,/gi,"");if(i.length<7)for(let t=7;t>i.length;t++)i="0"+i;return e[parseInt(i,2)]},Rann.prototype.clipGradients=function(t,e){let i=this.dU.max();if(i>e){let t=e/i;this.dU.map((e=>e*t))}let r=this.dV.max();if(r>e){let t=e/r;this.dV.map((e=>e*t))}let n=this.dW.max();if(n>e){let t=e/n;this.dW.map((e=>e*t))}let o=this.dU.min();if(o<t){let e=t/o;this.dU.map((t=>t*e))}let s=this.dV.min();if(s<t){let e=t/s;this.dV.map((t=>t*e))}let a=this.dW.min();if(a<t){let e=t/a;this.dW.map((t=>t*e))}},Rann.prototype.feed=function(t,e){let i=!1,r=!1,n=!1,o=21,s=!1;if(void 0!==e&&(void 0!==e.log&&(i=e.log),void 0!==e.table&&(n=e.table),void 0!==e.decimals&&(e.decimals>21?(DannError.warn("Maximum number of decimals is 21, was set to 21 by default.","Rann.prototype.feed"),e.decimals=21):(o=Math.pow(10,e.decimals),r=!0))),"string"==typeof t[0]&&(t=Rann.inputToNum(t),s=!0),this.validateSequences(t)){this.normalize&&(t=this.normalizeSequence(t));for(let e=0;e<t.length;e++){this.previous=new Matrix(this.h,1);let i=t[e],r=t[e].length;for(let t=0;t<r;t++){new_input=new Matrix(r,1),new_input.matrix[t][0]=i[t],this.mulu=Matrix.mult(this.U,new_input),this.mulw=Matrix.mult(this.W,this.previous);let e=Matrix.add(this.mulw,this.mulu),n=Matrix.map(e,this.actfunc);this.mulv=Matrix.mult(this.V,n),this.previous=n,this.output=this.mulv}}let e=Matrix.map(this.output,this.o_actfunc),a=Matrix.toArray(e);return this.normalize&&(a=this.unNormalizeSequence([a])[0]),r&&(a=a.map((t=>Math.round(t*o)/o))),i&&(n?(console.log("Prediction:"),console.table(a)):(console.log("Prediction:"),console.log(a))),!0===s&&(console.log(a),a=Rann.numToOutput(a)),a}DannError.error("Input sequences length must equal the number of input neurons the Rann model has","Rann.prototype.feed")},Rann.prototype.fromJSON=function(t){this.i=t.i,this.h=t.h,this.o=t.o,this.arch=JSON.parse(t.arch),this.lr=t.lr,this.largestSequenceValue=t.lsv,this.truncate=t.trun,this.epoch=t.e,this.loss=t.loss,this.layers=[];let e=JSON.parse(t.layers);for(let t=0;t<e.length;t++){let i=(new Matrix).set(e[t].current.matrix),r=(new Matrix).set(e[t].previous.matrix);this.layers[t]={current:i,previous:r}}this.U=(new Matrix).set(JSON.parse(t.U)),this.V=(new Matrix).set(JSON.parse(t.V)),this.W=(new Matrix).set(JSON.parse(t.W)),this.dU=(new Matrix).set(JSON.parse(t.dU)),this.dV=(new Matrix).set(JSON.parse(t.dV)),this.dW=(new Matrix).set(JSON.parse(t.dW)),this.dU_t=(new Matrix).set(JSON.parse(t.dU_t)),this.dV_t=(new Matrix).set(JSON.parse(t.dV_t)),this.dW_t=(new Matrix).set(JSON.parse(t.dW_t)),this.dU_i=(new Matrix).set(JSON.parse(t.dU_i)),this.dW_i=(new Matrix).set(JSON.parse(t.dW_i)),this.setLossFunction(t.lf),this.setActivation(t.act),this.o_actname="linear",this.o_actfunc=t=>t,this.o_actfunc_d=t=>1},Rann.inputToNum=function(t){let e=Rann.ascii(),i="";for(let e=0;e<t.length;e++)i+=" "+t[e];let r=[];for(let t=0;t<i.length;t++){let n=e.indexOf(i[t]);r.push(numberToBinary(n,7))}return r},Rann.prototype.log=function(t){let e,i=!1,r=!1,n=!1,o=!1,s=!1;if(void 0===t){console.log("Rann model:"),console.log("Layers:");for(let t=0;t<this.arch.length;t++)0!==t&&t!==this.arch.length-1?console.log("     hidden layer: "+this.arch[t]+"   ("+this.actname+")"):0===t?console.log("     Input layer: "+this.arch[t]):t===this.arch.length-1&&console.log("     output layer: "+this.arch[t]+"   ("+this.o_actname+")");console.log("Other values"),console.log("     Learning rate: "+this.lr),console.log("     Loss function: "+this.lossfunc_s),console.log("     Current epoch: "+this.epoch),console.log("     Latest loss: "+this.loss)}else{if(e=console.log,void 0!==t.weights&&(i=t.weights),void 0!==t.gradients&&(r=t.gradients),void 0!==t.struct&&(n=t.struct),void 0!==t.misc&&(o=t.misc),void 0!==t.table&&(s=t.table),void 0!==t.details&&!0===t.details&&(n=t.details,r=t.details,o=t.details,i=t.details),n){console.log("Rann model:"),console.log("Layers:");for(let t=0;t<this.arch.length;t++)0!==t&&t!==this.arch.length-1?console.log("     hidden layer: "+this.arch[t]+"   ("+this.actname+")"):0===t?console.log("     Input layer: "+this.arch[t]):t===this.arch.length-1&&console.log("     output layer: "+this.arch[t]+"   ("+this.o_actname+")")}if(o&&(console.log("Other values"),console.log("     Learning rate: "+this.lr),console.log("     Loss function: "+this.lossfunc_s),console.log("     Current epoch: "+this.epoch),console.log("     Latest loss: "+this.loss)),o&&i&&console.log(""),i){let t,i,r;s?(e=console.table,t=this.U.matrix,i=this.W.matrix,r=this.V.matrix):(e=console.log,t=this.U,i=this.W,r=this.V),console.log("U: input to hidden weights"),e(t),console.log("W: shared hidden weights"),e(i),console.log("V: hidden to output weights"),e(r)}if(i&&r&&console.log(""),r){let t,i,r;s?(e=console.table,t=this.dU.matrix,i=this.dW.matrix,r=this.dV.matrix):(e=console.log,t=this.dU,i=this.dW,r=this.dV),console.log("Gradients of U:"),e(t),console.log("Gradients of W:"),e(i),console.log("Gradients of V:"),e(r)}}},Rann.prototype.makeWeights=function(t,e){if(void 0!==t||void 0!==e)return this.U.randomize(t,e),this.V.randomize(t,e),void this.W.randomize(t,e);DannError.error("Must specify minimum and maximum values for weights","Rann.prototype.makeWeights")},Rann.prototype.normalizeSequence=function(t,e){if(void 0!==e&&!0===e){let e=[];for(let i=0;i<t.length;i++)e=e.concat(t[i]);let i=Math.max.apply(1,e);this.largestSequenceValue<i&&(this.largestSequenceValue=i)}let i=[],r=t[0].length;for(let e=0;e<t.length;e++){i[e]=[];for(let n=0;n<r;n++)i[e].push(t[e][n]/this.largestSequenceValue)}return i},Rann.numToOutput=function(t){let e=Rann.ascii(),i=[];for(let e=0;e<t.length;e++)i.push(Math.round(t[e]));let r=i.toString().replace(/,/gi,"");return e[parseInt(r,2)]},Rann.prototype.outputActivation=function(t){if(void 0===activations[t]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.outputActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.outputActivation");this.o_actname=t;let e=Layer.stringTofunc(this.o_actname);this.o_actfunc=e.func,this.o_actfunc_d=e.func_d},Rann.prototype.setActivation=function(t){if(void 0===activations[t]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.setActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.setActivation");this.actname=t;let e=Layer.stringTofunc(this.actname);this.actfunc=e.func,this.actfunc_d=e.func_d},Rann.prototype.setLossFunction=function(t){if(void 0===lossfuncs[t])return"string"==typeof t?void DannError.error("'"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default.","Rann.prototype.setLossFunction"):void DannError.error("Did not detect string value, as a result, the loss function is set to 'mse' by default.","Rann.prototype.setLossFunction");this.lossfunc_s=t,this.lossfunc=lossfuncs[t]},Rann.prototype.toJSON=function(){let t=JSON.stringify(this.arch),e=JSON.stringify(this.U.matrix),i=JSON.stringify(this.V.matrix),r=JSON.stringify(this.W.matrix),n=JSON.stringify(this.dU.matrix),o=JSON.stringify(this.dV.matrix),s=JSON.stringify(this.dW.matrix),a=JSON.stringify(this.dU_t.matrix),l=JSON.stringify(this.dV_t.matrix),h=JSON.stringify(this.dW_t.matrix),u=JSON.stringify(this.dU_i.matrix),c=JSON.stringify(this.dW_i.matrix),f=JSON.stringify(this.layers);return{i:this.i,h:this.h,o:this.o,act:this.actname,act_o:this.o_actname,lsv:this.largestSequenceValue,trun:this.truncate,loss:this.loss,e:this.epoch,lf:this.lossfunc_s,lr:this.lr,arch:t,layers:f,U:e,V:i,W:r,dU:n,dV:o,dW:s,dU_t:a,dV_t:l,dW_t:h,dU_i:u,dW_i:c}},Rann.prototype.train=function(t,e){let i=!1;if(void 0!==e&&void 0!==e.log&&(i=e.log),this.validateSequences(t)){"string"==typeof t[0]&&(t=Rann.inputToNum(t)),this.normalize&&(t=this.normalizeSequence(t,!0));let e=Object.assign([],t),r=e.length-1;for(let t=0;t<r;t++){let t=e.splice(e.length-1,1);this.trainSequence(e,t[0])}i&&console.log("Loss: ",this.loss)}else DannError.error("Input sequences length must equal the number of input neurons the Rann model has","Rann.prototype.train")},Rann.prototype.trainSequence=function(t,e){if(this.validateSequences(t)){let i,r,n=Matrix.fromArray(e);for(let o=0;o<t.length;o++){this.previous=new Matrix(this.h,1),r=t[o],i=r.length,this.layers=[],this.dU=new Matrix(this.h,this.i),this.dV=new Matrix(this.o,this.h),this.dW=new Matrix(this.h,this.h),this.dU_t=new Matrix(this.h,this.i),this.dV_t=new Matrix(this.o,this.h),this.dW_t=new Matrix(this.h,this.h),this.dU_i=new Matrix(this.h,this.i),this.dW_i=new Matrix(this.h,this.h);for(let t=0;t<i;t++){new_input=new Matrix(i,1),new_input.matrix[t][0]=r[t],this.mulu=Matrix.mult(this.U,new_input),this.mulw=Matrix.mult(this.W,this.previous);let e=Matrix.add(this.mulw,this.mulu);this.sum=e;let n=Matrix.map(e,this.actfunc);this.mulv=Matrix.mult(this.V,n),this.layers.push({current:n,previous:this.previous}),this.previous=n}this.dmulv=Matrix.sub(this.mulv,n),this.loss=this.lossfunc(Matrix.toArray(this.mulv),e)}for(let t=0;t<i;t++){this.dV_t=Matrix.mult(this.dmulv,Matrix.transpose(this.layers[t].current));let e=Matrix.mult(Matrix.transpose(this.V),this.dmulv),n=this.sum,o=this.sum,s=new Matrix(n.rows,n.cols);s.initiate(1);let a=Matrix.sub(s,o),l=n.mult(e),h=a.mult(l),u=new Matrix(this.mulw.rows,this.mulw.cols);u.initiate(1),this.dmulw=h.mult(u);let c=Math.max(-1,t-this.truncate-1);for(let e=t-1;e>c;e-=1){let e=new Matrix(this.mulu.rows,this.mulu.cols);e.initiate(1),this.dmulu=h.mult(e),this.dW_i=Matrix.mult(this.W,this.layers[t].previous);let n=new Matrix(i,1);n.matrix[t][0]=r[t],this.dU_i=Matrix.mult(this.U,n),this.dU_t=Matrix.addColumn(this.dU_t,this.dU_i),this.dW_t=Matrix.addColumn(this.dW_t,this.dW_i)}this.dV.add(this.dV_t),this.dU.add(this.dU_t),this.dW.add(this.dW_t)}return this.clipGradients(-10,10),this.U.sub(this.dU.mult(this.lr)),this.V.sub(this.dV.mult(this.lr)),void this.W.sub(this.dW.mult(this.lr))}DannError.error("Input sequences length must equal the number of input neurons the Rann model has","Rann.prototype.trainSequence")},Rann.prototype.unNormalizeSequence=function(t){let e=[];for(let i=0;i<t.length;i++){e[i]=[];for(let r=0;r<t[0].length;r++)e[i].push(t[i][r]*this.largestSequenceValue)}return e},Rann.prototype.validateSequences=function(t){for(let e=0;e<t.length;e++)if(t[e].length!==this.i)return!1;return!0},isBrowser||(module.exports={dann:Dann,rann:Rann,layer:Layer,matrix:Matrix,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs,xor:XOR,makeXOR:makeXOR,makeBinary:makeBinary,makeSinWave:makeSinWave,add:Add});