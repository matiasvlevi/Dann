/*! Dann.js */
const isBrowser="object"!=typeof process,VERSION="v2.4.1e";function bitLength(t){return t<1?1:Math.floor(Math.log(t)/Math.log(2))+1}function numberToBinary(t,e){let r=t.toString(2),i=[],o=bitLength(t)-1;for(let t=e-1;t>=0;t--){let e=r.charAt(o);i[t]=""===e?0:JSON.parse(e),o--}return i}function makeBinary(t,e){let r;r=void 0!==e?e:function(t){return t+1};let i=[];for(let e=0;e<Math.pow(2,t)-1;e++){let o=r(e);if(bitLength(o)<=t){let r={input:numberToBinary(e,t),output:numberToBinary(o,t)};i.push(r)}}return i}function makeXOR(t){if(t<2)return[];let e=makeBinary(t),r={input:e[e.length-1].output,output:[]};return e.push(r),e.forEach((t=>{delete t.output,t.output=[t.input.reduce(((t,e)=>t+e),0)%2]})),e}isBrowser||(global.Cuno=require("cuno"));const XOR=makeXOR(2);DannError=function(t,e){this.msg=t,this.method=e},DannError.prototype.warn=function(){isBrowser?(console.error("DannWarning: "+this.msg),console.error("> "+this.method)):(console.error("[33mDannWarning: "+this.msg+"[0m"),console.error("[33m> "+this.method+"[0m")),console.trace()},DannError.prototype.error=function(){isBrowser?(console.warn("DannError: "+this.msg),console.warn("> "+this.method)):(console.warn("[31mDannError: "+this.msg+"[0m"),console.warn("[31m> "+this.method+"[0m")),console.trace()},DannError.warn=function(t,e){isBrowser?(console.warn("DannWarning: "+t),console.warn("> "+e)):(console.warn("[33mDannWarning: "+t+"[0m"),console.warn("[33m> "+e+"[0m")),console.trace()},DannError.error=function(t,e){isBrowser?(console.error("DannError: "+t),console.error("> "+e)):(console.error("[31mDannError: "+t+"[0m"),console.error("[31m> "+e+"[0m")),console.trace()};let activations={sigmoid:t=>1/(1+Math.exp(-t)),sigmoid_d(t){let e=1/(1+Math.exp(-t));return e*(1-e)},silu:t=>t/(1+Math.exp(-t)),silu_d:t=>(1+Math.exp(-t)+t*Math.exp(-t))/Math.pow(1+Math.exp(-t),2),tanh:t=>(Math.exp(t)-Math.exp(-t))/(Math.exp(t)+Math.exp(-t)),tanh_d:t=>1-Math.pow(Math.exp(2*t)-1,2)/Math.pow(Math.exp(2*t)+1,2),leakyrelu:t=>Math.max(t,.01*t),leakyrelu_d:t=>t>=0?1:.01,relu:t=>Math.max(t,0),relu_d:t=>t>=0?1:0,sinc:t=>0===t?1:Math.sin(t)/t,sinc_d:t=>0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t),softsign:t=>t/(1+Math.abs(t)),softsign_d(t){let e=1+Math.abs(t);return 1/(e*e)},binary:t=>t<=0?0:1,binary_d:t=>0,softplus:t=>Math.log(1+Math.exp(t)),softplus_d:t=>1/(1+Math.exp(-t)),leakyrelucapped:t=>t>=0&&t<=6?t:t<0?.1*t:6,leakyrelucapped_d:t=>t>=0&&t<=6?1:t<0?.1:0,leakysigmoid:t=>1/(1+Math.exp(-t))+t/100,leakysigmoid_d:t=>Math.exp(-t)/Math.pow(Math.exp(-t)+1,2)+.01},lossfuncs={mae(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=abs(o-n)}return i=r/o,i},bce(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=o*log(n)+(1-o)*log(1-n)}return i=-r/o,i},lcl(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=log(cosh(n-o))}return i=r/o,i},mbe(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){r+=e[i]-t[i]}return i=r/o,i},mael(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i]-t[i];r+=-o*(exp(-o)-1)/(exp(-o)+1)}return i=r/o,i},rmse(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=pow(o-n,2)}return i=sqrt(r/o),i},mce(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=pow(abs(o-n),3)}return i=r/o,i},mse(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=pow(o-n,2)}return i=r/o,i},quantile(t,e,r){let i=r,o=0;for(let r=0;r<e.length;r++)e[r]-t[r]>=0?o+=i*(e[r]-t[r]):o+=(i-1)*(e[r]-t[r]);return o/e.length}};const random=(t,e)=>Math.random(1)*(e-t)+t,exp=t=>Math.exp(t),abs=t=>Math.abs(t),log=t=>Math.log(t),pow=(t,e)=>Math.pow(t,e),round=t=>Math.round(t),sqrt=t=>Math.sqrt(t),cosh=t=>(exp(t)+exp(-t))/2;let poolfuncs={max:function(t){let e=0,r=t.length;for(let i=0;i<r;i++)t[i]>e&&(e=t[i]);return e},min:function(t){let e=1/0,r=t.length;for(let i=0;i<r;i++)t[i]<e&&(e=t[i]);return e},avg:function(t){let e=0,r=t.length;for(let i=0;i<r;i++)e+=t[i];return e/r}};function matchReplace(t,e,r){let i=t.match(e);return null===i||i.forEach(((e,i)=>{t=t.replace(e,r)})),t}function minify(t){return t=matchReplace(t,/ = /g,"="),t=matchReplace(t,/ \+ /g,"+"),t=matchReplace(t,/ - /g,"-"),t=matchReplace(t,/ \* /g,"*"),t=matchReplace(t,/ \/ /g,"/"),t=matchReplace(t,/for \(/g,"for("),t=matchReplace(t,/; /g,";"),t=matchReplace(t,/\) {/g,"){"),t=matchReplace(t,/ < /g,"<"),t=matchReplace(t,/ > /g,">"),t=matchReplace(t,/ \+= /g,"+="),t=matchReplace(t,/;\}/g,"}"),t=matchReplace(t,/\{ /g,"{"),t=matchReplace(t,/ \{/g,"{"),t=matchReplace(t,/\} /g,"}"),t=matchReplace(t,/\t/g,""),t=matchReplace(t,/\n/g,""),t=matchReplace(t,/; /g,";"),t=matchReplace(t,/[ ]{2,}/g," ")}function isES6(t){return null!==t.match(/([a-z] {0,1}=> {0,1}).*/gm)}function toES6(t){if(isES6(t))return t;let e=t.match(/\(.*?\)/gm)[0],r=t.split("\r").join("").split("\n").join("").match(/{.*?}/),i="";return null!==r?i=r[0].trimEnd().trimStart():DannError.error("Something went wrong, we couldn't find the function definition. ","toFunction call to toES6"),i=matchReplace(i,/{ /g,"{"),i=matchReplace(i,/ }/g,"}"),`${e}=>${i}`}Matrix=function(t=0,e=0){this.rows=t,this.cols=e;let r=[[]];for(let i=0;i<t;i++){r[i]=[];for(let t=0;t<e;t++)r[i][t]=0}this.matrix=r},Matrix.prototype.add=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.add");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]+=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]+=t;return this},Matrix.add=function(t,e){let r=new Matrix(t.rows,t.cols);if(t.rows===e.rows&&t.cols===e.cols){for(let i=0;i<r.rows;i++)for(let o=0;o<r.cols;o++)r.matrix[i][o]=t.matrix[i][o]+e.matrix[i][o];return r}DannError.error("Matrix dimensions should match","Matrix.add")},Matrix.prototype.addPercent=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){let i=this.matrix[e][r];this.matrix[e][r]+=i*t}},Matrix.prototype.addRandom=function(t,e){let r=Matrix.make(this.rows,this.cols);if(e<=0||e>1)DannError.error("Probability argument must be between 0 and 1","Matrix.prototype.addRandom");else for(let i=0;i<this.rows;i++)for(let o=0;o<this.cols;o++){let n=this.matrix[i][o];random(0,1)<e&&(r[i][o]=n+n*random(-t,t))}this.set(r)},Matrix.prototype.fillCol=function(t,e){if(!(t>=this.cols)){for(let r=0;r<this.rows;r++)this.matrix[r][t]=e;return this}DannError.error("The column index specified is too large for this matrix.","Matrix.prototype.fillCol")},Matrix.prototype.fillRow=function(t,e){if(!(t>=this.rows))return this.matrix[t].fill(e),this;DannError.error("The row index specified is too large for this matrix.","Matrix.prototype.fillRow")},Matrix.fromArray=function(t){let e=new Matrix(t.length,1);for(let r=0;r<t.length;r++)e.matrix[r][0]=t[r];return e},Matrix.prototype.initiate=function(t=0){if(void 0===t);else{if("number"==typeof t){for(let e=0;e<this.matrix.length;e++)for(let r=0;r<this.matrix[e].length;r++)this.matrix[e][r]=t;return this}DannError.error("The value entered as an argument is not a number","Matrix.prototype.initiate")}},Matrix.prototype.insert=function(t,e,r){if("number"==typeof t)if("number"==typeof e){if("number"==typeof r)return e<this.rows&&r<this.cols?(this.matrix[e][r]=t,this):void DannError.error(" x, y arguments exceed the matrix dimensions.","Matrix.prototype.insert");DannError.error('Expected Number for "y" argument',"Matrix.prototype.insert")}else DannError.error('Expected Number for "x" argument',"Matrix.prototype.insert");else DannError.error('Expected Number for "value" argument',"Matrix.prototype.insert")},Matrix.prototype.log=function(t={table:!1,decimals:void 0}){let e=new Matrix(this.rows,this.cols);if(e.set(this.matrix),void 0!==t.decimals){let r=1e3;t.decimals>21?(DannError.warn("Maximum number of decimals is 21.","Matrix.prototype.log"),r=pow(10,21)):r=pow(10,t.decimals)||r,e.map((t=>round(t*r)/r))}t.table?console.table(e.matrix):console.log(e)},Matrix.make=function(t=0,e=0){let r=[[]];for(let i=0;i<t;i++){r[i]=[];for(let t=0;t<e;t++)r[i][t]=0}return r},Matrix.prototype.map=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){let i=this.matrix[e][r];this.matrix[e][r]=t(i)}return this},Matrix.map=function(t,e){if(t instanceof Matrix){for(let r=0;r<t.rows;r++)for(let i=0;i<t.cols;i++){let o=t.matrix[r][i];t.matrix[r][i]=e(o)}return t}DannError.error("First argument must be an instance of Matrix","Matrix.map")},Matrix.prototype.mult=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("The matrix dimensions should match in order to multiply their values. If you are looking for dot product, try Matrix.mult","Matrix.prototype.mult");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]*=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]*=t;return this},Matrix.mult=function(t,e,r={mode:"cpu"}){if(void 0!==r&&r.mode&&(mode=r.mode),"cpu"===mode){let r=new Matrix(t.rows,e.cols);if(t instanceof Matrix&&e instanceof Matrix){if(t.cols!==e.rows)return void DannError.error("The rows of B must match the columns of A","Matrix.mult");for(let i=0;i<r.rows;i++)for(let o=0;o<r.cols;o++){let n=0;for(let r=0;r<t.cols;r++)n+=t.matrix[i][r]*e.matrix[r][o];r.matrix[i][o]=n}return r}}else DannError.error("mode specified is not valid","Matrix.prototype.mult")},Matrix.prototype.randomize=function(t,e){for(let r=0;r<this.matrix.length;r++)for(let i=0;i<this.matrix[r].length;i++)this.matrix[r][i]=random(t,e);return this},Matrix.prototype.set=function(t){if("number"==typeof t.length&&"number"==typeof t[0].length&&"object"==typeof t){this.rows=t.length,this.cols=t[0].length;for(let e=0;e<this.rows;e++)this.matrix[e]=[...t[e]]}else DannError.error("the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]","Matrix.prototype.set")},Matrix.prototype.sub=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.sub");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]-=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]-=t;return this},Matrix.sub=function(t,e){if(t instanceof Matrix&&e instanceof Matrix){if(t.rows!==e.rows||t.cols!==e.cols)return void DannError.error("The matrix dimensions should match","Matrix.sub");{let r=new Matrix(t.rows,t.cols);for(let i=0;i<r.rows;i++)for(let o=0;o<r.cols;o++)r.matrix[i][o]=t.matrix[i][o]-e.matrix[i][o];return r}}DannError.error("The arguments should be p5.MatrixTensors","Matrix.sub")},Matrix.prototype.toArray=function(){let t=[];if(1===this.cols){for(let e=0;e<this.rows;e++)t[e]=this.matrix[e][0];return t}return 1===this.rows?(t=this.matrix[0],t):void DannError.error("None of the lengths of the matrix equal 1","Matrix.prototype.toArray")},Matrix.toArray=function(t){let e=[];if(1===t.cols){for(let r=0;r<t.rows;r++)e[r]=t.matrix[r][0];return e}return 1===t.rows?(e=t.matrix[0],e):void DannError.error("None of the lengths of the matrix equal 1","Matrix.toArray")},Matrix.transpose=function(t){let e=new Matrix(t.cols,t.rows);for(let r=0;r<t.rows;r++)for(let i=0;i<t.cols;i++)e.matrix[i][r]=t.matrix[r][i];return e},Layer=function t(e,r,i,o,n,s){if(this.type=e,this.subtype=this.getSubtype(),"pool"!==this.subtype)"hidden"===this.type||"output"===this.type?(this.size=r,this.setFunc(i),this.layer=new Matrix(this.size,1)):"input"===this.type&&(this.size=r,this.layer=new Matrix(this.size,1));else if("pool"===this.subtype){if(this.stride=o,this.sampleSize=i,this.inputSize=r,void 0!==n&&void 0!==s)this.sizeX=n,this.sizeY=s;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=t.getPoolOutputLength(i,o,this.sizeX,this.sizeY);let e=this.inputSize/this.sizeX,a=this.inputSize/this.sizeY;if(e!==Math.floor(e)&&a!==Math.floor(a))return void DannError.error("the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)","Layer.constructor");if(this.size!==Math.floor(this.size))return void DannError.error("the Width must be divisible by the stride (jumps size). Width is the root of the array's length.","Layer.constructor");this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1),this.prefix=this.getPrefix(),this.poolfunc=poolfuncs[this.prefix],this.downsample=function(e,r,i){this.input=Matrix.fromArray(e);let o=t.selectPools(e,r,i,this.sizeX,this.sizeY),n=[];for(let t=0;t<o.length;t++)n[t]=this.poolfunc(o[t]);return this.layer=Matrix.fromArray(n),n}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())},Layer.prototype.feed=function(t,e){if("pool"===this.subtype){let r=!1,i=!1,o=this.sampleSize,n=this.stride;if(void 0!==e&&(e.log&&(r=e.log),e.table&&(i=e.table)),t.length!==this.inputSize)return void DannError.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has.","Layer.prototype.feed");{let e=this.downsample(t,o,n);return r&&(i?console.table(e):console.log(e)),e}}DannError.error("This function can only be used by Layers with 'pool' subtype","Layer.prototype.feed")},Layer.getPoolOutputLength=function(t,e,r,i){return((r-t)/e+1)*((i-t)/e+1)},Layer.getSqIndex=function(t,e,r){return t*r+e},Layer.prototype.log=function(){console.log(this)},Layer.selectPools=function(t,e,r,i,o){t.length;if(i!==Math.floor(i))return;if(i/r!==Math.floor(i/r))return;let n=[];for(let s=0;s+e<=o;s+=r)for(let o=0;o+e<=i;o+=r){let r=[];for(let n=0;n<e;n++)for(let a=0;a<e;a++)r.push(t[Layer.getSqIndex(i,a+o,n+s)]);n.push(r)}return n},Layer.prototype.setFunc=function(t){const e=t.toLocaleLowerCase();let r=Layer.stringTofunc(e);void 0!==r?(this.actname=r.name,this.actname_d=r.name_d,this.actfunc=r.func,this.actfunc_d=r.func_d):DannError.error("Bad activation information","Layer.prototype.setFunc")},Layer.stringTofunc=function(t){let e,r,i=t.toLocaleLowerCase(),o=i+"_d";return e=activations[i],r=activations[o],void 0!==e?void 0!==r?{name:i,name_d:o,func:e,func_d:r}:void DannError.error("You need to create the derivative of your custom function. The activation function specified '"+t+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc"):void DannError.error("the activation function '"+t+"' is not a valid activation function. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc")},Layer.prototype.getPrefix=function(){let t=this.type,e=t.length;return t.slice(0,e-4)},Layer.prototype.getSubtype=function(){let t=this.type,e=t.length,r=t.slice(e-4,e);return"pool"===r?r:t},Dann=function(t=1,e=1){this.i=t,this.inputs=new Layer("input",t),this.o=e,this.outputs=new Layer("output",e,"sigmoid"),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.dropout=[],this.outs=[],this.loss=0,this.lr=.001,this.arch=[t,e],this.epoch=0,this.recordLoss=!1,this.lossfunc=lossfuncs.mse,this.lossfunc_s=this.lossfunc.name,this.percentile=.5},Dann.asLabel=function(t){return t.indexOf(Math.max(...t))},Dann.logDefaults=function(){return{struct:!0,misc:!0,weights:!1,gradients:!1,errors:!1,layers:!1,table:!1,decimals:void 0,details:!1}},Dann.ffwDefaults=function(){return{log:!1,table:!1,decimals:void 0,asLabel:!1}},Dann.bckDefaults=function(){return{log:!1,mode:"cpu",table:!1,dropout:void 0}},Dann.print=function(t,e=!1){e?console.table(t):console.log(t)},Dann.prototype.checkArrayLength=function(t,e){return t.length===e},Dann.prototype.checkLearningRate=function(){return"number"!=typeof this.lr?(DannError.error("The learning rate specified (Dann.lr property) is not a number.","Dann.prototype.backpropagate"),!1):!(this.lr>=1)||(DannError.error("The learning rate specified is greater or equal to 1","Dann.prototype.backpropagate"),!1)},Dann.prototype.checkDropoutRate=function(t){return t>=1?(DannError.error("The probability value can not be bigger or equal to 1","Dann.prototype.backpropagate"),!1):!(t<=0)||(DannError.error("The probability value can not be smaller or equal to 0","Dann.prototype.backpropagate"),!1)},Dann.prototype.addDropout=function addDropout(rate){if(0===this.weights.length)return void DannError.error("You need to initialize weights before using this function, use Dann.prototype.makeWeights();","Dann.prototype.addDropout");let func=(t=>{let e=1-rate;return Math.floor(Math.random()+e)}).toString().replace(/rate/gm,rate),randomMap=eval(func),inactive=[];for(let t=0;t<this.Layers.length;t++){let e=new Array(this.Layers[t].size).fill(1).map(randomMap);inactive.push(e)}this.dropout=[];for(let t=0;t<this.weights.length;t++)this.dropout.push(new Matrix(this.weights[t].rows,this.weights[t].cols).initiate(1));for(let t=0;t<inactive.length;t++)if(0===t)for(let e=0;e<inactive[t].length;e++)0===inactive[t][e]&&this.dropout[t].fillCol(e,0);else if(t===inactive.length-1)for(let e=0;e<inactive[t].length;e++)0===inactive[t][e]&&this.dropout[t-1].fillRow(e,0);else for(let e=0;e<inactive[t].length;e++)0===inactive[t][e]&&(this.dropout[t-1].fillRow(e,0),this.dropout[t].fillCol(e,0))},Dann.prototype.addHiddenLayer=function(t,e){if(void 0!==e){const t=e.toLocaleLowerCase();void 0===activations[t]&&("string"==typeof e&&DannError.error("'"+e+"' is not a valid activation function, as a result, the activation function was set to 'sigmoid'.","Dann.prototype.addHiddenLayer"),e="sigmoid")}else e="sigmoid";this.arch.splice(this.arch.length-1,0,t);let r=new Layer("hidden",t,e);this.Layers.splice(this.Layers.length-1,0,r)},Dann.prototype.makeWeights=function(t,e){let r=-1,i=1;void 0!==t&&void 0!==e&&(r=t,i=e);for(let t=0;t<this.Layers.length-1;t++){let e=this.Layers[t],o=this.Layers[t+1],n=new Matrix(o.layer.rows,e.layer.rows),s=new Matrix(o.layer.rows,1);n.randomize(r,i),s.randomize(1,-1),this.weights[t]=n,this.biases[t]=s,this.errors[t]=new Matrix(o.layer.rows,1),this.gradients[t]=new Matrix(o.layer.rows,1),void 0===o.actfunc&&o.setFunc("sigmoid")}for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t];this.arch[t]=e.layer.rows}},Dann.prototype.outputActivation=function(t){const e=t.toLocaleLowerCase();if(void 0===activations[e]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation");this.Layers[this.Layers.length-1].setFunc(t)},Dann.prototype.setLossFunction=function(t,e=.5){this.percentile=e;let r=lossfuncs[t];if(void 0===r)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default.","Dann.prototype.setLossFunction"):void DannError.error("Did not detect string value, as a result, the loss function is set to 'mse' by default.","Dann.prototype.setLossFunction");this.lossfunc_s=t,this.lossfunc=r},Dann.prototype.feedForward=function(t,e=Dann.ffwDefaults()){let r=void 0!==e.decimals,i=pow(10,e.decimals)||1e3;if(!this.checkArrayLength(t,this.i))return void DannError.error("The input array length does not match the number of inputs the dannjs model has.","Dann.prototype.feedForward");this.Layers[0].layer=Matrix.fromArray(t),this.checkArrayLength(this.weights,0)&&(DannError.warn("The weights were not initiated. Please use the Dann.makeWeights(); function after the initialization of the layers.","Dann.prototype.feedForward"),this.makeWeights());for(let t=0;t<this.weights.length;t++){let e=this.Layers[t],r=this.Layers[t+1];r.layer=Matrix.mult(this.weights[t],e.layer),r.layer.add(this.biases[t]),r.layer.map(r.actfunc)}this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer);let o=this.outs;return r&&e.asLabel?DannError.warn("Cannot round if output is a label","Dann.prototype.feedForward"):e.asLabel?o=Dann.asLabel(o):r&&!e.asLabel&&(o=o.map((t=>round(t*i)/i))),!0===e.log&&(Dann.print("Prediction: "),Dann.print(o,e.table)),o},Dann.prototype.feed=function(){return this.feedForward.apply(this,arguments)},Dann.prototype.log=function(t=Dann.logDefaults()){let e=1e3;if(t.decimals>21?(DannError.error("Maximum number of decimals is 21.","Dann.prototype.log"),e=pow(10,21)):e=pow(10,t.decimals)||e,t.details){let e=t.details;t.gradients=e,t.weights=e,t.errors=e,t.biases=e,t.struct=e,t.misc=e,t.layers=e}if(0===this.weights.length&&this.makeWeights(),t.struct){console.log("Dann Model:"),console.log("Layers:");for(let e=0;e<this.Layers.length;e++){let r=this.Layers[e],i=`${r.type} Layer:`,o="";0===e?(i="input Layer:",o="       "):e===this.Layers.length-1?(i="output Layer:",o=`  (${r.actname})`):o=`  (${r.actname})`;let n="  ";console.log(`\t${i}${n}${r.size}${o}`),t.layers&&console.log(this.Layers[e])}}if(t.errors){console.log("Errors:");for(let e=0;e<this.errors.length;e++){this.errors[e].log({decimals:t.decimals,table:t.table})}}if(t.gradients){console.log("Gradients:");for(let e=0;e<this.gradients.length;e++){this.gradients[e].log({decimals:t.decimals,table:t.table})}}if(t.weights){console.log("Weights:");for(let e=0;e<this.weights.length;e++){this.weights[e].log({decimals:t.decimals,table:t.table})}}if(t.biases){console.log("Biases:");for(let e=0;e<this.biases.length;e++){this.biases[e].log({decimals:t.decimals,table:t.table})}}t.misc&&(console.log("Other Values: "),console.log(`\tLearning rate: ${this.lr}`),console.log(`\tLoss Function: ${this.lossfunc_s}`),console.log(`\tCurrent Epoch: ${this.epoch}`),console.log(`\tLatest Loss: ${this.loss}`)),console.log("\n")},Dann.prototype.backpropagate=function(t,e,r=Dann.bckDefaults()){let i;if(!this.checkArrayLength(e,this.o))return void DannError.error("The target array length does not match the number of ouputs the dannjs model has.","Dann.prototype.backpropagate");if(i=Matrix.fromArray(e),!this.checkLearningRate())return;if(void 0!==r.dropout){if(!this.checkDropoutRate(r.dropout))return;this.addDropout(r.dropout)}this.outs=this.feedForward(t,{log:!1,mode:r.mode}),this.errors[this.errors.length-1]=Matrix.sub(i,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d).mult(this.errors[this.errors.length-1]).mult(this.lr);for(let t=this.weights.length-1;t>0;t--){let e=Matrix.mult(this.gradients[t],Matrix.transpose(this.Layers[t].layer));void 0!==r.dropout&&(e=e.mult(this.dropout[t])),this.weights[t].add(e),this.biases[t].add(this.gradients[t]);let i=Matrix.transpose(this.weights[t]);this.errors[t-1]=Matrix.mult(i,this.errors[t]),this.gradients[t-1]=Matrix.map(this.Layers[t].layer,this.Layers[t].actfunc_d).mult(this.errors[t-1]).mult(this.lr)}let o=Matrix.transpose(this.Layers[0].layer),n=Matrix.mult(this.gradients[0],o);void 0!==r.dropout&&(n=n.mult(this.dropout[0])),this.weights[0].add(n),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,e,this.percentile),!0===r.log&&(Dann.print("Prediction: "),Dann.print(this.outs,r.table),Dann.print("target: "),Dann.print(e,r.table),Dann.print(`Loss: ${this.loss}`))},Dann.prototype.train=function(){if(void 0===arguments[1]||!arguments[1].gpu)return this.backpropagate.apply(this,arguments);this.kernel_train.apply(this,arguments)},Dann.prototype.kernel_train=function(t,e){let r=[];for(let t=0;t<this.weights.length;t++){let e=[];for(let r=0;r<this.weights[t].rows;r++)e=e.concat(this.weights[t].matrix[r]);r.push(e)}let i=[];for(let t=0;t<this.biases.length;t++){let e=[];for(let r=0;r<this.biases[t].rows;r++)e=e.concat(this.biases[t].matrix[r]);i.push(e)}t=t.map((t=>Object.values(t))),console.log(this);let o=global.Cuno.train(this);console.log(o)},Dann.prototype.mapWeights=function(t){if("function"==typeof t)for(let e=0;e<this.weights.length;e++)this.weights[e].map(t);else DannError.error("Argument must be a function","Dann.prototype.mapWeights")},Dann.prototype.mutateAdd=function(t){if("number"==typeof t)for(let e=0;e<this.weights.length;e++)this.weights[e].addPercent(t);else DannError.error("randomFactor argument must be a number.","Dann.prototype.mutateAdd")},Dann.prototype.mutateRandom=function(t,e){if("number"==typeof t){if(void 0!==e){if("number"!=typeof e)return void DannError.error("Probability argument must be a number.","Dann.prototype.mutateRandom")}else e=1;for(let r=0;r<this.weights.length;r++)this.weights[r].addRandom(t,e)}else DannError.error("Range argument must be a number.","Dann.prototype.mutateRandom")},Dann.createFromJSON=function(t){const e=new Dann;return e.fromJSON(t),e},Dann.prototype.fromJSON=function(t){this.i=t.arch[0],this.inputs=new Matrix(this.i,1),this.o=t.arch[t.arch.length-1],this.outputs=new Matrix(this.o,1);let e=JSON.parse(t.lstr);for(let t=0;t<e.length;t++){let r=JSON.parse(e[t]),i=new Layer(r.type,r.size,r.actname);this.Layers[t]=i}this.makeWeights();let r=JSON.parse(t.wstr);for(let t=0;t<r.length;t++)this.weights[t].set(JSON.parse(r[t]));let i=JSON.parse(t.bstr);for(let t=0;t<i.length;t++)this.biases[t].set(JSON.parse(i[t]));let o=JSON.parse(t.estr);for(let t=0;t<o.length;t++)this.errors[t].set(JSON.parse(o[t]));let n=JSON.parse(t.gstr);for(let t=0;t<n.length;t++)this.gradients[t].set(JSON.parse(n[t]));return this.lossfunc_s=t.lf,this.lossfunc=isBrowser?window[t.lf]:lossfuncs[t.lf],this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer),this.loss=t.loss,this.lr=t.lrate,this.arch=t.arch,this.epoch=t.e,this.percentile=t.per,this},Dann.prototype.toFunction=function(t="myDannFunction"){let e="function "+t+"(input) {";e+="let w = [];";for(let t=0;t<this.weights.length;t++)e+="w["+t+"] = "+JSON.stringify(this.weights[t].matrix)+";";e+="let b = [];";for(let t=0;t<this.biases.length;t++)e+="b["+t+"] = "+JSON.stringify(this.biases[t].matrix)+";";e+="let c = "+JSON.stringify(this.arch)+";",e+="let a = [];";for(let t=1;t<this.Layers.length;t++){let r=this.Layers[t].actname;if(0!==t){let i=toES6(activations[r].toString()),o="";for(let t=0;t<i.length;t++)o+=i[t];i=o.split("\t");let n="";for(let t=0;t<i.length;t++)n+=i[t];e+="a["+t+"] = "+n+";"}else e+="a["+t+"] = undefined;"}return e+="let l = [];",e+="l[0] = [];for (let i = 0; i < "+this.i+"; i++) {l[0][i] = [input[i]];};",e+="for (let i = 1; i < "+this.Layers.length+"; i++) {l[i] = [];for (let j = 0; j < c[i]; j++) {l[i][j] = [0];}};",e+="for (let m = 0; m < "+this.weights.length+"; m++) {for (let i = 0; i < w[m].length; i++) {for (let j = 0; j < l[m][0].length; j++) {let sum = 0;for (let k = 0; k < w[m][0].length; k++) {sum += w[m][i][k] * l[m][k][j];};l[m+1][i][j] = sum;}};for (let i = 0; i < l[m+1].length; i++) {for (let j = 0; j < l[m+1][0].length; j++) {l[m+1][i][j] = l[m+1][i][j] + b[m][i][j];}};for (let i = 0; i < l[m+1].length; i++) {for (let j = 0; j < l[m+1][0].length; j++) {l[m+1][i][j] = a[m+1](l[m+1][i][j]);}}};let o = [];for (let i = 0; i < "+this.o+"; i++) {o[i] = l["+(this.Layers.length-1)+"][i][0];};return o}",minify(e)},Dann.prototype.toJSON=function(){let t=[];for(let e=0;e<this.weights.length;e++)t[e]=JSON.stringify(this.weights[e].matrix);let e=JSON.stringify(t),r=[];for(let t=0;t<this.Layers.length;t++)r[t]=JSON.stringify(this.Layers[t]);let i=JSON.stringify(r),o=[];for(let t=0;t<this.biases.length;t++)o[t]=JSON.stringify(this.biases[t].matrix);let n=JSON.stringify(o),s=[];for(let t=0;t<this.errors.length;t++)s[t]=JSON.stringify(this.errors[t].matrix);let a=JSON.stringify(s),l=[];for(let t=0;t<this.gradients.length;t++)l[t]=JSON.stringify(this.gradients[t].matrix);return{wstr:e,lstr:i,bstr:n,estr:a,gstr:JSON.stringify(l),arch:this.arch,lrate:this.lr,lf:this.lossfunc_s,loss:this.loss,e:this.epoch,per:this.percentile}},Add=function(){},Add.activation=function(t,e,r){if("string"==typeof t){if(1===e.length&&1===r.length){const i=t.toLocaleLowerCase();return activations[i]=e,void(activations[i+"_d"]=r)}DannError.error("One of the functions specified does not have only 1 argument.","Add.activation")}else DannError.error("The name argument is not a string.","Add.activation")},Add.loss=function(t,e){"string"==typeof t?2===e.length?lossfuncs[t]=e:DannError.error("The loss function specified can only have 2 argument.","newActivation"):DannError.error("The name argument is not a string.","Add.loss")},isBrowser||(module.exports={Dann:Dann,Layer:Layer,Matrix:Matrix,Add:Add,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs,XOR:XOR,makeXOR:makeXOR,makeBinary:makeBinary,dann:Dann,layer:Layer,matrix:Matrix,add:Add,xor:XOR});