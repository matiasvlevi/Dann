const isBrowser="object"!=typeof process,VERSION="v2.2.11";function bitLength(t){return t<1?1:Math.floor(Math.log(t)/Math.log(2))+1}function numberToBinary(t,e){let i=t.toString(2),r=[],s=bitLength(t)-1;for(let t=e-1;t>=0;t--){let e=i.charAt(s);r[t]=""===e?0:JSON.parse(e),s--}return r}function makeBinary(t,e){let i;i=void 0!==e?e:function(t){return t+1};let r=[];for(let e=0;e<Math.pow(2,t)-1;e++){let s=i(e);if(bitLength(s)<=t){let i={input:numberToBinary(e,t),output:numberToBinary(s,t)};r.push(i)}}return r}function makeSinWave(t,e,i){let r=[];for(let s=0;s<t*e*i;s+=i)r.push(Math.sin(s));r.length===t*e+1&&r.splice(r.length-1,1);let s=[];for(let i=0;i<e;i++)s.push(r.slice(i*t,i*t+t));return s}function makeXOR(t){if(t<2)return[];let e=makeBinary(t),i={input:e[e.length-1].output,output:[]};return e.push(i),e.forEach((t=>{delete t.output,t.output=[t.input.reduce(((t,e)=>t+e),0)%2]})),e}Add=function(){},Add.activation=function(t,e,i){if("string"==typeof t)return 1!==e.length||1!==i.length?void DannError.error("One of the functions specified does not have only 1 argument.","Add.activation"):(activations[t]=e,void(activations[t+"_d"]=i));DannError.error("The name argument is not a string.","Add.activation")},Add.loss=function(t,e){"string"==typeof t?2===e.length?lossfuncs[t]=e:DannError.error("The loss function specified can only have 2 argument.","newActivation"):DannError.error("The name argument is not a string.","Add.loss")};const XOR=makeXOR(2);function sigmoid(t){return 1/(1+Math.exp(-t))}function sigmoid_d(t){let e=sigmoid(t);return e*(1-e)}function leakySigmoid(t){return 1/(1+Math.exp(-t))+t/100}function leakySigmoid_d(t){let e=leakySigmoid(t);return e*(1-e)}function siLU(t){return t/(1+Math.exp(-t))}function siLU_d(t){return(1+Math.exp(-t)+t*Math.exp(-t))/Math.pow(1+Math.exp(-t),2)}function tanH(t){return(Math.exp(t)-Math.exp(-t))/(Math.exp(t)+Math.exp(-t))}function tanH_d(t){return 1-Math.pow(tanH(t),2)}function leakyReLUCapped(t){return t>=0&&t<=6?t:t<0?.1*t:6}function leakyReLUCapped_d(t){return t>=0&&t<=6?1:t<0?.1:0}function leakyReLU(t){return t>=0?1*t:.01*t}function leakyReLU_d(t){return t>=0?1:.01}function reLU(t){return t>=0?1*t:0}function reLU_d(t){return t>=0?1:0}function sinc(t){return 0===t?1:Math.sin(t)/t}function sinc_d(t){return 0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t)}function softsign(t){return t/(1+Math.abs(t))}function softsign_d(t){let e=1+Math.abs(t);return 1/(e*e)}function binary(t){return t<=0?0:1}function binary_d(t){return 0}function softplus(t){return Math.log(1+Math.exp(t))}function softplus_d(t){return sigmoid(t)}DannError=function(t,e){this.msg=t,this.method=e},DannError.prototype.warn=function(){isBrowser?(console.error("DannWarning: "+this.msg),console.error("> "+this.method)):(console.error("[33mDannWarning: "+this.msg+"[0m"),console.error("[33m> "+this.method+"[0m")),console.trace()},DannError.prototype.error=function(){isBrowser?(console.warn("DannError: "+this.msg),console.warn("> "+this.method)):(console.warn("[31mDannError: "+this.msg+"[0m"),console.warn("[31m> "+this.method+"[0m")),console.trace()},DannError.warn=function(t,e){isBrowser?(console.warn("DannWarning: "+t),console.warn("> "+e)):(console.warn("[33mDannWarning: "+t+"[0m"),console.warn("[33m> "+e+"[0m")),console.trace()},DannError.error=function(t,e){isBrowser?(console.error("DannError: "+t),console.error("> "+e)):(console.error("[31mDannError: "+t+"[0m"),console.error("[31m> "+e+"[0m")),console.trace()};let activations={sigmoid:sigmoid,sigmoid_d:sigmoid_d,tanH:tanH,tanH_d:tanH_d,siLU:siLU,siLU_d:siLU_d,reLU:reLU,reLU_d:reLU_d,leakyReLU:leakyReLU,leakyReLU_d:leakyReLU_d,sinc:sinc,sinc_d:sinc_d,softsign:softsign,softsign_d:softsign_d,binary:binary,binary_d:binary_d,softplus:softplus,softplus_d:softplus_d,leakySigmoid:leakySigmoid,leakySigmoid_d:leakySigmoid_d,leakyReLUCapped:leakyReLUCapped,leakyReLUCapped_d:leakyReLUCapped_d};function mae(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){let s=e[r],o=t[r];i+=abs(s-o)}return r=i/s,r}function bce(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){let s=e[r],o=t[r];i+=s*log(o)+(1-s)*log(1-o)}return r=-i/s,r}function lcl(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){let s=e[r],o=t[r];i+=log(cosh(o-s))}return r=i/s,r}function mbe(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){i+=e[r]-t[r]}return r=i/s,r}function mael(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){let s=e[r]-t[r];i+=-s*(exp(-s)-1)/(exp(-s)+1)}return r=i/s,r}function rmse(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){let s=e[r],o=t[r];i+=pow(s-o,2)}return r=sqrt(i/s),r}function mce(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){let s=e[r],o=t[r];i+=pow(abs(s-o),3)}return r=i/s,r}function mse(t,e){let i=0,r=0,s=e.length;for(let r=0;r<s;r++){let s=e[r],o=t[r];i+=pow(s-o,2)}return r=i/s,r}function quantile(t,e,i){let r=i,s=0;for(let i=0;i<e.length;i++)e[i]-t[i]>=0?s+=r*(e[i]-t[i]):s+=(r-1)*(e[i]-t[i]);return s/e.length}let lossfuncs={mae:mae,bce:bce,lcl:lcl,mbe:mbe,mce:mce,mse:mse,rmse:rmse,mael:mael,quantile:quantile};const random=(t,e)=>Math.random(1)*(e-t)+t,exp=t=>Math.exp(t),abs=t=>Math.abs(t),log=t=>Math.log(t),pow=(t,e)=>Math.pow(t,e),round=t=>Math.round(t),sqrt=t=>Math.sqrt(t),cosh=t=>(exp(t)+exp(-t))/2;let poolfuncs={max:function(t){let e=0,i=t.length;for(let r=0;r<i;r++)t[r]>e&&(e=t[r]);return e},min:function(t){let e=1/0,i=t.length;for(let r=0;r<i;r++)t[r]<e&&(e=t[r]);return e},avg:function(t){let e=0,i=t.length;for(let r=0;r<i;r++)e+=t[r];return e/i}};function minify(t){t=(t=(t=(t=(t=(t=(t=(t=(t=(t=(t=(t=t.replace(/ = /g,"=")).replace(/ \+ /g,"+")).replace(/ - /g,"-")).replace(/ \* /g,"*")).replace(/ \/ /g,"/")).replace(/for \(/g,"for(")).replace(/; /g,";")).replace(/\) {/g,"){")).replace(/ < /g,"<")).replace(/ > /g,">")).replace(/ \+= /g,"+=")).replace(/;\}/g,"}");for(let e=0;e<5;e++)t=(t=(t=(t=(t=t.replace(/\{ /g,"{")).replace(/ \{/g,"{")).replace(/\} /g,"}")).replace(/\t/g,"")).replace(/\n/g,"");for(let e=0;e<5;e++)t=t.replace(/; /g,";");return t}function slicestring(t,e){return[t.slice(0,e+1),t.slice(e+1,t.length)]}function toEs6(t){let e=t.toString(),i=e.indexOf("("),r=slicestring(e,i)[1];i=r.indexOf(")");let s=slicestring(r,i-1),o=s[0];return i=s[1].indexOf(")"),minify("("+o+")=>"+slicestring(s[1],i)[1])}Matrix=function(t=0,e=0){this.rows=t,this.cols=e,this.shape="( "+this.rows+" , "+this.cols+" )";let i=[[]];for(let r=0;r<t;r++){i[r]=[];for(let t=0;t<e;t++)i[r][t]=0}this.matrix=i},Matrix.prototype.add=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.add");for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]+=t.matrix[e][i];return this}for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]+=t;return this},Matrix.add=function(t,e){let i=new Matrix(t.rows,t.cols);if(t.rows===e.rows&&t.cols===e.cols){for(let r=0;r<i.rows;r++)for(let s=0;s<i.cols;s++)i.matrix[r][s]=t.matrix[r][s]+e.matrix[r][s];return i}DannError.error("Matrix dimensions should match","Matrix.add")},Matrix.addGrid=function(t,e){let i=t.matrix,r=e.matrix,s=[];for(let t=0;t<i[0].length;t++){s[t]=[];for(let e=0;e<i[0].length;e++)s[t].push(i[0][t]+r[e][0])}return(new Matrix).set(s)},Matrix.addColumn=function(t,e){let i,r;1===t.cols?(i=t,r=e):1===e.cols&&(i=e,r=t);let s=new Matrix(r.rows,r.cols);for(let t=0;t<r.rows;t++)for(let e=0;e<r.cols;e++)s.matrix[t][e]=r.matrix[t][e]+i.matrix[t][0];return s},Matrix.prototype.addPercent=function(t){for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];this.matrix[e][i]+=r*t}},Matrix.prototype.addRandom=function(t,e){let i=Matrix.make(this.rows,this.cols);if(e<=0||e>1)DannError.error("Probability argument must be between 0 and 1","Matrix.prototype.addRandom");else for(let r=0;r<this.rows;r++)for(let s=0;s<this.cols;s++){let o=this.matrix[r][s];random(0,1)<e&&(i[r][s]=o+o*random(-t,t))}this.set(i)},Matrix.fromArray=function(t,e){let i=!1;void 0!==e&&(i=e.flip);let r=new Matrix(t.length,1);for(let e=0;e<t.length;e++)!1===i?r.matrix[e][0]=t[e]:!0===i&&(r.matrix[0][e]=t[e]);return r},Matrix.prototype.initiate=function(t=0){if(void 0===t);else{if("number"==typeof t){for(let e=0;e<this.matrix.length;e++)for(let i=0;i<this.matrix[e].length;i++)this.matrix[e][i]=t;return this}DannError.error("The value entered as an argument is not a number","Matrix.prototype.initiate")}},Matrix.prototype.insert=function(t,e,i){if("number"==typeof t)if("number"==typeof e){if("number"==typeof i)return e<this.rows&&i<this.cols?(this.matrix[e][i]=t,this):void DannError.error(" x, y arguments exceed the matrix dimensions.","Matrix.prototype.insert");DannError.error('Expected Number for "y" argument',"Matrix.prototype.insert")}else DannError.error('Expected Number for "x" argument',"Matrix.prototype.insert");else DannError.error('Expected Number for "value" argument',"Matrix.prototype.insert")},Matrix.prototype.log=function(t){let e=!1;void 0!==t&&t.table&&(e=t.table),e?console.table(this.matrix):console.log(this)},Matrix.make=function(t=0,e=0){let i=[[]];for(let r=0;r<t;r++){i[r]=[];for(let t=0;t<e;t++)i[r][t]=0}return i},Matrix.prototype.makeShape=function(){return"( "+this.rows+" , "+this.cols+" )"},Matrix.prototype.map=function(t){if("function"==typeof t){for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];this.matrix[e][i]=t(r)}return this}DannError.error("Argument must be a function","Matrix.prototype.map")},Matrix.map=function(t,e){if(t instanceof Matrix){let i=new Matrix(t.rows,t.cols);for(let r=0;r<t.rows;r++)for(let s=0;s<t.cols;s++){let o=t.matrix[r][s];i.matrix[r][s]=e(o)}return i}DannError.error("First argument must be an instance of Matrix","Matrix.map")},Matrix.prototype.max=function(){let t=0;for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];t<r&&(t=r)}return t},Matrix.prototype.min=function(){let t=1e10;for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){let r=this.matrix[e][i];t>r&&(t=r)}return t},Matrix.prototype.mult=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("The matrix dimensions should match in order to multiply their values. If you are looking for dot product, try Matrix.mult","Matrix.prototype.mult");for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]*=t.matrix[e][i];return this}for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]*=t;return this},Matrix.mult=function(t,e,i={mode:"cpu"}){if(void 0!==i&&i.mode&&(mode=i.mode),"cpu"===mode){let i=new Matrix(t.rows,e.cols);if(t instanceof Matrix&&e instanceof Matrix){if(t.cols!==e.rows)return void DannError.error("The rows of B must match the columns of A","Matrix.mult");for(let r=0;r<i.rows;r++)for(let s=0;s<i.cols;s++){let o=0;for(let i=0;i<t.cols;i++)o+=t.matrix[r][i]*e.matrix[i][s];i.matrix[r][s]=o}return i}}else DannError.error("mode specified is not valid","Matrix.prototype.mult")},Matrix.prototype.randomize=function(t,e){for(let i=0;i<this.matrix.length;i++)for(let r=0;r<this.matrix[i].length;r++)this.matrix[i][r]=random(t,e);return this},Matrix.prototype.set=function(t){return"number"==typeof t.length&&"number"==typeof t[0].length&&"object"==typeof t?(this.matrix=t,this.rows=t.length,this.cols=t[0].length,this.shape=this.makeShape(),this):void DannError.error("the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]","Matrix.prototype.set")},Matrix.prototype.sub=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.sub");for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]-=t.matrix[e][i];return this}for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)this.matrix[e][i]-=t;return this},Matrix.sub=function(t,e){if(t instanceof Matrix&&e instanceof Matrix){if(t.rows!==e.rows||t.cols!==e.cols)return void DannError.error("The matrix dimensions should match","Matrix.sub");{let i=new Matrix(t.rows,t.cols);for(let r=0;r<i.rows;r++)for(let s=0;s<i.cols;s++)i.matrix[r][s]=t.matrix[r][s]-e.matrix[r][s];return i}}DannError.error("The arguments should be Matrices","Matrix.sub")},Matrix.prototype.toArray=function(){let t=[];if(1===this.cols){for(let e=0;e<this.rows;e++)t[e]=this.matrix[e][0];return t}return 1===this.rows?(t=this.matrix[0],t):void DannError.error("None of the lengths of the matrix equal 1","Matrix.prototype.toArray")},Matrix.toArray=function(t){let e=[];if(1===t.cols){for(let i=0;i<t.rows;i++)e[i]=t.matrix[i][0];return e}return 1===t.rows?(e=t.matrix[0],e):void DannError.error("None of the lengths of the matrix equal 1","Matrix.toArray")},Matrix.transpose=function(t){let e=new Matrix(t.cols,t.rows);for(let i=0;i<t.rows;i++)for(let r=0;r<t.cols;r++)e.matrix[r][i]=t.matrix[i][r];return e},Layer=function t(e,i,r,s,o,n){if(this.type=e,this.subtype=this.getSubtype(),"pool"!==this.subtype)"hidden"===this.type||"output"===this.type?(this.size=i,this.setFunc(r),this.layer=new Matrix(this.size,1)):"input"===this.type&&(this.size=i,this.layer=new Matrix(this.size,1));else if("pool"===this.subtype){if(this.stride=s,this.sampleSize=r,this.inputSize=i,void 0!==o&&void 0!==n)this.sizeX=o,this.sizeY=n;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=t.getPoolOutputLength(r,s,this.sizeX,this.sizeY);let e=this.inputSize/this.sizeX,a=this.inputSize/this.sizeY;if(e!==Math.floor(e)&&a!==Math.floor(a))return console.error("Dann Error: the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)"),void console.trace();if(this.size!==Math.floor(this.size))return console.error("Dann Error: the Width must be divisible by the stride (jumps size). Width is the root of the array's length."),void console.trace();this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1),this.prefix=this.getPrefix(),this.poolfunc=poolfuncs[this.prefix],this.downsample=function(e,i,r){this.input=Matrix.fromArray(e);let s=t.selectPools(e,i,r,this.sizeX,this.sizeY),o=[];for(let t=0;t<s.length;t++)o[t]=this.poolfunc(s[t]);return this.layer=Matrix.fromArray(o),o}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())},Layer.prototype.feed=function(t,e){if("pool"===this.subtype){let i=!1,r=!1,s=this.sampleSize,o=this.stride;if(void 0!==e&&(e.log&&(i=e.log),e.table&&(r=e.table)),t.length!==this.inputSize)return void DannError.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has.","Layer.prototype.feed");{let e=this.downsample(t,s,o);return i&&(r?console.table(e):console.log(e)),e}}DannError.error("This function can only be used by Layers with 'pool' subtype","Layer.prototype.feed")},Layer.getPoolOutputLength=function(t,e,i,r){return((i-t)/e+1)*((r-t)/e+1)},Layer.getSqIndex=function(t,e,i){return t*i+e},Layer.prototype.log=function(){console.log(this)},Layer.selectPools=function(t,e,i,r,s){t.length;if(r!==Math.floor(r))return;if(r/i!==Math.floor(r/i))return;let o=[];for(let n=0;n+e<=s;n+=i)for(let s=0;s+e<=r;s+=i){let i=[];for(let o=0;o<e;o++)for(let a=0;a<e;a++)i.push(t[Layer.getSqIndex(r,a+s,o+n)]);o.push(i)}return o},Layer.prototype.setFunc=function(t){let e=Layer.stringTofunc(t);void 0!==e?(this.actname=e.name,this.actname_d=e.name_d,this.actfunc=e.func,this.actfunc_d=e.func_d):DannError.error("Bad activation information","Layer.prototype.setFunc")},Layer.stringTofunc=function(t){let e,i,r=t,s=r+"_d";return e=activations[r],i=activations[s],void 0!==e?void 0!==i?{name:r,name_d:s,func:e,func_d:i}:void DannError.error("Dann Error: You need to create the derivative of your custom function. The activation function specified '"+t+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc"):void DannError.error("Dann Error: the activation function '"+t+"' is not a valid activation function. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc")},Layer.prototype.getPrefix=function(){let t=this.type,e=t.length;return t.slice(0,e-4)},Layer.prototype.getSubtype=function(){let t=this.type,e=t.length,i=t.slice(e-4,e);return"pool"===i?i:t},Dann=function(t=1,e=1){this.i=t,this.inputs=new Layer("input",t),this.o=e,this.outputs=new Layer("output",e,"sigmoid"),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.outs=[],this.loss=100,this.losses=[],this.lr=.001,this.arch=[t,e],this.epoch=0,this.recordLoss=!1,this.lossfunc=mse,this.lossfunc_s=this.lossfunc.name,this.percentile=.5},Dann.prototype.addHiddenLayer=function(t,e){void 0!==e?void 0===activations[e]&&("string"==typeof e&&DannError.error("'"+e+"' is not a valid activation function, as a result, the activation function was set to 'sigmoid'.","Dann.prototype.addHiddenLayer"),e="sigmoid"):e="sigmoid",this.arch.splice(this.arch.length-1,0,t);let i=new Layer("hidden",t,e);this.Layers.splice(this.Layers.length-1,0,i)},Dann.prototype.backpropagate=function(t,e,i){let r=!1,s="cpu",o=!1,n=!1;void 0!==i&&(r=void 0!==i.log&&i.log,void 0!==i.table&&(n=i.table),void 0!==i.mode?(s=i.mode,"gpu"===s&&console.log("gpu version coming soon"),s="cpu"):s="cpu",o=void 0===i.saveLoss||i.saveLoss);let a=new Matrix(0,0);if(e.length!==this.o)return console.error("Dann Error: The target array length does not match the number of ouputs the dannjs model has."),void console.trace();if(a=Matrix.fromArray(e),"number"!=typeof this.lr)return console.error("Dann Error: The learning rate specified (Dann.lr property) is not a number."),void console.trace();this.outs=this.feedForward(t,{log:!1,mode:s}),this.errors[this.errors.length-1]=Matrix.sub(a,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d),this.gradients[this.gradients.length-1].mult(this.errors[this.errors.length-1]),this.gradients[this.gradients.length-1].mult(this.lr);for(let t=this.weights.length-1;t>0;t--){let e=Matrix.transpose(this.Layers[t].layer),i=Matrix.mult(this.gradients[t],e);this.weights[t].add(i),this.biases[t].add(this.gradients[t]);let r=Matrix.transpose(this.weights[t]);this.errors[t-1]=Matrix.mult(r,this.errors[t]),this.gradients[t-1]=Matrix.map(this.Layers[t].layer,this.Layers[t].actfunc_d),this.gradients[t-1].mult(this.errors[t-1]),this.gradients[t-1].mult(this.lr)}let l=Matrix.transpose(this.Layers[0].layer),h=Matrix.mult(this.gradients[0],l);this.weights[0].add(h),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,e,this.percentile),!0===o&&this.losses.push(this.loss),!0===r&&(console.log("Prediction: "),n?console.table(this.outs):console.log(this.outs),console.log("target: "),n?console.table(e):console.log(e),console.log("Loss: ",this.loss))},Dann.prototype.train=function(t,e,i){return this.backpropagate(t,e,i)},Dann.createFromJSON=function(t){const e=new Dann;return e.fromJSON(t),e},Dann.prototype.feedForward=function(t,e){let i,r,s=!1,o="cpu",n=!1,a=!1,l=1e3;if(void 0!==e&&(s=void 0!==e.log&&e.log,void 0!==e.table&&(n=e.table),void 0!==e.pull&&(i=e.pull),void 0!==e.insert&&(r=e.insert),void 0!==e.decimals&&(e.decimals>21&&(DannError.warn("Maximum number of decimals is 21, was set to 21 by default.","Dann.prototype.feedForward"),e.decimals=21),l=pow(10,e.decimals),a=!0),void 0!==e.mode?(o=e.mode,"gpu"===o&&(DannError.warn("Gpu Support not available yet, mode set to 'cpu'","Dann.prototype.feedForward"),o="cpu")):o="cpu"),t.length!==this.i){for(let t=0;t<this.o;t++)this.outs[t]=0;return DannError.error("The input array length does not match the number of inputs the dannjs model has.","Dann.prototype.feedForward"),this.outs}this.Layers[0].layer=Matrix.fromArray(t),0===this.weights.length&&(DannError.warn("The weights were not initiated. Please use the Dann.makeWeights(); function after the initialization of the layers.","Dann.prototype.feedForward"),this.makeWeights());for(let t=0;t<this.weights.length;t++){let e=this.Layers[t],i=this.Layers[t+1];i.layer=Matrix.mult(this.weights[t],e.layer),void 0!==r&&t+1===r.layer&&i.layer.add(Matrix.fromArray(r.value)),i.layer.add(this.biases[t]),i.layer.map(i.actfunc)}if(void 0===i){this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer);let t=this.outs;return!0===s&&(!0===a&&(t=t.map((t=>Math.round(t*l)/l))),!0===n?(console.log("Prediction: "),console.table(t)):(console.log("Prediction: "),console.log(t))),t}return this.Layers[i].layer.toArray()},Dann.prototype.feed=function(t,e){return this.feedForward(t,e)},Dann.prototype.fromJSON=function(t){this.i=t.arch[0],this.inputs=new Matrix(this.i,1),this.o=t.arch[t.arch.length-1],this.outputs=new Matrix(this.o,1);let e=JSON.parse(t.lstr);for(let t=0;t<e.length;t++){let i=JSON.parse(e[t]),r=new Layer(i.type,i.size,i.actname);this.Layers[t]=r}this.makeWeights();let i=JSON.parse(t.wstr);for(let t=0;t<i.length;t++)this.weights[t].set(JSON.parse(i[t]));let r=JSON.parse(t.bstr);for(let t=0;t<r.length;t++)this.biases[t].set(JSON.parse(r[t]));let s=JSON.parse(t.estr);for(let t=0;t<s.length;t++)this.errors[t].set(JSON.parse(s[t]));let o=JSON.parse(t.gstr);for(let t=0;t<o.length;t++)this.gradients[t].set(JSON.parse(o[t]));return this.lossfunc_s=t.lf,this.lossfunc=isBrowser?window[t.lf]:lossfuncs[t.lf],this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer),this.loss=t.loss,this.losses=[],this.lr=t.lrate,this.arch=t.arch,this.epoch=t.e,this.percentile=t.per,this},Dann.prototype.log=function(t){let e=!1,i=!1,r=!1,s=!1,o=!1,n=!1,a=!1,l=!1,h=1e3;if(void 0!==t){if(t.weights&&(e=t.weights),t.gradients&&(i=t.gradients),t.errors&&(r=t.errors),t.biases&&(s=t.biases),t.struct&&(o=t.struct),t.misc&&(n=t.misc),t.table&&(l=t.table),t.layers&&(a=t.layers,o=t.layers),t.details){let l=t.details;i=l,e=l,r=l,s=l,o=l,n=l,a=l}t.decimals&&(t.decimals>21&&(console.error("Dann Error: Maximum number of decimals is 21."),console.trace(),t.decimals=21),h=pow(10,t.decimals))}else o=!0,n=!0;if(0===this.weights.length&&this.makeWeights(),(void 0===t||void 0!==t&&!0===t.details)&&console.log("Dann model:"),o){console.log("Layers:");for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t],i=e.type+" Layer: ",r="";0===t?(i="Input Layer:   ",r="       "):t===e.length-1?(i="Output Layer:  ",r="  ("+e.actname+")"):r="  ("+e.actname+")",console.log("\t"+i+e.size+r),a&&console.log(this.Layers[t])}}if(r){console.log("Errors:");for(let t=0;t<this.errors.length;t++){let e=Matrix.toArray(this.errors[t]),i=[];for(let t=0;t<e.length;t++)i[t]=round(e[t]*h)/h;console.log(i)}}if(i){console.log("Gradients:");for(let t=0;t<this.gradients.length;t++){let e=Matrix.toArray(this.gradients[t]),i=[];for(let t=0;t<e.length;t++)i[t]=round(e[t]*h)/h;console.log(i)}}if(e){console.log("Weights:");for(let e=0;e<this.weights.length;e++){this.weights[e].log({decimals:t.decimals,table:l})}}if(s){console.log("Biases:");for(let t=0;t<this.biases.length;t++){let e=Matrix.toArray(this.biases[t]),i=[];for(let t=0;t<e.length;t++)i[t]=round(e[t]*h)/h;console.log(i)}}n&&(console.log("Other Values: "),console.log("\tLearning rate: "+this.lr),console.log("\tLoss Function: "+this.lossfunc_s),console.log("\tCurrent Epoch: "+this.epoch),console.log("\tLatest Loss: "+this.loss)),console.log(" ")},Dann.prototype.makeWeights=function(t,e){let i=-1,r=1;void 0!==t&&void 0!==e&&(i=t,r=e);for(let t=0;t<this.Layers.length-1;t++){let e=this.Layers[t],s=this.Layers[t+1],o=new Matrix(s.layer.rows,e.layer.rows),n=new Matrix(s.layer.rows,1);o.randomize(i,r),n.randomize(1,-1),this.weights[t]=o,this.biases[t]=n,this.errors[t]=new Matrix(s.layer.rows,1),this.gradients[t]=new Matrix(s.layer.rows,1),void 0===s.actfunc&&s.setFunc("sigmoid")}for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t];this.arch[t]=e.layer.rows}},Dann.prototype.mapWeights=function(t){if("function"==typeof t)for(let e=0;e<this.weights.length;e++)this.weights[e].map(t);else DannError.error("Argument must be a function","Dann.prototype.mapWeights")},Dann.prototype.mutateAdd=function(t){if("number"==typeof t)for(let e=0;e<this.weights.length;e++)this.weights[e].addPercent(t);else DannError.error("randomFactor argument must be a number.","Dann.prototype.mutateAdd")},Dann.prototype.mutateRandom=function(t,e){if("number"==typeof t){if(void 0!==e){if("number"!=typeof e)return void DannError.error("Probability argument must be a number.","Dann.prototype.mutateRandom")}else e=1;for(let i=0;i<this.weights.length;i++)this.weights[i].addRandom(t,e)}else DannError.error("Range argument must be a number.","Dann.prototype.mutateRandom")},Dann.prototype.outputActivation=function(t){if(void 0===activations[t]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation");this.Layers[this.Layers.length-1].setFunc(t)},Dann.prototype.setLossFunction=function(t,e=.5){this.percentile=e;let i=lossfuncs[t];if(void 0===i)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default.","Dann.prototype.setLossFunction"):void DannError.error("Did not detect string value, as a result, the loss function is set to 'mse' by default.","Dann.prototype.setLossFunction");this.lossfunc_s=t,this.lossfunc=i},Dann.prototype.toFunction=function(t="myDannFunction"){let e="function "+t+"(input) {";e+="let w = [];";for(let t=0;t<this.weights.length;t++)e+="w["+t+"] = "+JSON.stringify(this.weights[t].matrix)+";";e+="let b = [];";for(let t=0;t<this.biases.length;t++)e+="b["+t+"] = "+JSON.stringify(this.biases[t].matrix)+";";e+="let c = "+JSON.stringify(this.arch)+";",e+="let a = [];";for(let t=1;t<this.Layers.length;t++){let i=this.Layers[t].actname;if(0!==t){let r=toEs6(activations[i]).toString().split("\n"),s="";for(let t=0;t<r.length;t++)s+=r[t];r=s.split("\t");let o="";for(let t=0;t<r.length;t++)o+=r[t];e+="a["+t+"] = "+o+";"}else e+="a["+t+"] = undefined;"}return e+="let l = [];",e+="l[0] = [];for (let i = 0; i < "+this.i+"; i++) {l[0][i] = [input[i]];};",e+="for (let i = 1; i < "+this.Layers.length+"; i++) {l[i] = [];for (let j = 0; j < c[i]; j++) {l[i][j] = [0];}};",e+="for (let m = 0; m < "+this.weights.length+"; m++) {for (let i = 0; i < w[m].length; i++) {for (let j = 0; j < l[m][0].length; j++) {let sum = 0;for (let k = 0; k < w[m][0].length; k++) {sum += w[m][i][k] * l[m][k][j];};l[m+1][i][j] = sum;}};for (let i = 0; i < l[m+1].length; i++) {for (let j = 0; j < l[m+1][0].length; j++) {l[m+1][i][j] = l[m+1][i][j] + b[m][i][j];}};for (let i = 0; i < l[m+1].length; i++) {for (let j = 0; j < l[m+1][0].length; j++) {l[m+1][i][j] = a[m+1](l[m+1][i][j]);}}};let o = [];for (let i = 0; i < "+this.o+"; i++) {o[i] = l["+(this.Layers.length-1)+"][i][0];};return o}",minify(e)},Dann.prototype.toJSON=function(){let t=[];for(let e=0;e<this.weights.length;e++)t[e]=JSON.stringify(this.weights[e].matrix);let e=JSON.stringify(t),i=[];for(let t=0;t<this.Layers.length;t++)i[t]=JSON.stringify(this.Layers[t]);let r=JSON.stringify(i),s=[];for(let t=0;t<this.biases.length;t++)s[t]=JSON.stringify(this.biases[t].matrix);let o=JSON.stringify(s),n=[];for(let t=0;t<this.errors.length;t++)n[t]=JSON.stringify(this.errors[t].matrix);let a=JSON.stringify(n),l=[];for(let t=0;t<this.gradients.length;t++)l[t]=JSON.stringify(this.gradients[t].matrix);return{wstr:e,lstr:r,bstr:o,estr:a,gstr:JSON.stringify(l),arch:this.arch,lrate:this.lr,lf:this.lossfunc_s,loss:this.loss,e:this.epoch,per:this.percentile}},Rann=function(t=2,e=8,i=2){this.i=t,this.o=i,this.h=e,this.lr=.001,this.arch=[this.i,this.h,this.o],this.layers=[],this.U=new Matrix(this.h,this.i),this.V=new Matrix(this.o,this.h),this.W=new Matrix(this.h,this.h),this.dU=new Matrix(this.h,this.i),this.dV=new Matrix(this.o,this.h),this.dW=new Matrix(this.h,this.h),this.dU_t=new Matrix(this.h,this.i),this.dV_t=new Matrix(this.o,this.h),this.dW_t=new Matrix(this.h,this.h),this.dU_i=new Matrix(this.h,this.i),this.dW_i=new Matrix(this.h,this.h),this.U.randomize(-1,1),this.V.randomize(-1,1),this.W.randomize(-1,1),this.mulv,this.mulw,this.mulu,this.actname="sigmoid";let r=Layer.stringTofunc(this.actname);this.actfunc=r.func,this.actfunc_d=r.func_d,this.o_actname="linear",this.o_actfunc=t=>t,this.o_actfunc_d=t=>1,this.previous,this.input,this.output,this.normalize=!1,this.largestSequenceValue=1,this.truncate=5,this.loss=100,this.epoch=0,this.lossfunc_s="mse",this.lossfunc=lossfuncs[this.lossfunc_s]},Rann.ascii=function(){return" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"},Rann.asciiToBinary=function(t){return numberToBinary(Rann.ascii().indexOf(t),7)},Rann.binaryToAscii=function(t){let e=Rann.ascii(),i=t.toString().replace(/,/gi,"");if(i.length<7)for(let t=7;t>i.length;t++)i="0"+i;return e[parseInt(i,2)]},Rann.prototype.clipGradients=function(t,e){let i=this.dU.max();if(i>e){let t=e/i;this.dU.map((e=>e*t))}let r=this.dV.max();if(r>e){let t=e/r;this.dV.map((e=>e*t))}let s=this.dW.max();if(s>e){let t=e/s;this.dW.map((e=>e*t))}let o=this.dU.min();if(o<t){let e=t/o;this.dU.map((t=>t*e))}let n=this.dV.min();if(n<t){let e=t/n;this.dV.map((t=>t*e))}let a=this.dW.min();if(a<t){let e=t/a;this.dW.map((t=>t*e))}},Rann.prototype.feed=function(t,e){let i=!1,r=!1,s=!1,o=21,n=!1;if(void 0!==e&&(void 0!==e.log&&(i=e.log),void 0!==e.table&&(s=e.table),void 0!==e.decimals&&(e.decimals>21?(DannError.warn("Maximum number of decimals is 21, was set to 21 by default.","Rann.prototype.feed"),e.decimals=21):(o=Math.pow(10,e.decimals),r=!0))),"string"==typeof t[0]&&(t=Rann.inputToNum(t),n=!0),this.validateSequences(t)){this.normalize&&(t=this.normalizeSequence(t));for(let e=0;e<t.length;e++){this.previous=new Matrix(this.h,1);let i=t[e],r=t[e].length;for(let t=0;t<r;t++){new_input=new Matrix(r,1),new_input.matrix[t][0]=i[t],this.mulu=Matrix.mult(this.U,new_input),this.mulw=Matrix.mult(this.W,this.previous);let e=Matrix.add(this.mulw,this.mulu),s=Matrix.map(e,this.actfunc);this.mulv=Matrix.mult(this.V,s),this.previous=s,this.output=this.mulv}}let e=Matrix.map(this.output,this.o_actfunc),a=Matrix.toArray(e);return this.normalize&&(a=this.unNormalizeSequence([a])[0]),r&&(a=a.map((t=>Math.round(t*o)/o))),i&&(s?(console.log("Prediction:"),console.table(a)):(console.log("Prediction:"),console.log(a))),!0===n&&(console.log(a),a=Rann.numToOutput(a)),a}DannError.error("Input sequences length must equal the number of input neurons the Rann model has","Rann.prototype.feed")},Rann.prototype.fromJSON=function(t){this.i=t.i,this.h=t.h,this.o=t.o,this.arch=JSON.parse(t.arch),this.lr=t.lr,this.largestSequenceValue=t.lsv,this.truncate=t.trun,this.epoch=t.e,this.loss=t.loss,this.layers=[];let e=JSON.parse(t.layers);for(let t=0;t<e.length;t++){let i=(new Matrix).set(e[t].current.matrix),r=(new Matrix).set(e[t].previous.matrix);this.layers[t]={current:i,previous:r}}this.U=(new Matrix).set(JSON.parse(t.U)),this.V=(new Matrix).set(JSON.parse(t.V)),this.W=(new Matrix).set(JSON.parse(t.W)),this.dU=(new Matrix).set(JSON.parse(t.dU)),this.dV=(new Matrix).set(JSON.parse(t.dV)),this.dW=(new Matrix).set(JSON.parse(t.dW)),this.dU_t=(new Matrix).set(JSON.parse(t.dU_t)),this.dV_t=(new Matrix).set(JSON.parse(t.dV_t)),this.dW_t=(new Matrix).set(JSON.parse(t.dW_t)),this.dU_i=(new Matrix).set(JSON.parse(t.dU_i)),this.dW_i=(new Matrix).set(JSON.parse(t.dW_i)),this.setLossFunction(t.lf),this.setActivation(t.act),this.o_actname="linear",this.o_actfunc=t=>t,this.o_actfunc_d=t=>1},Rann.inputToNum=function(t){let e=Rann.ascii(),i="";for(let e=0;e<t.length;e++)i+=" "+t[e];let r=[];for(let t=0;t<i.length;t++){let s=e.indexOf(i[t]);r.push(numberToBinary(s,7))}return r},Rann.prototype.log=function(t){let e,i=!1,r=!1,s=!1,o=!1,n=!1;if(void 0===t){console.log("Rann model:"),console.log("Layers:");for(let t=0;t<this.arch.length;t++)0!==t&&t!==this.arch.length-1?console.log("     hidden layer: "+this.arch[t]+"   ("+this.actname+")"):0===t?console.log("     Input layer: "+this.arch[t]):t===this.arch.length-1&&console.log("     output layer: "+this.arch[t]+"   ("+this.o_actname+")");console.log("Other values"),console.log("     Learning rate: "+this.lr),console.log("     Loss function: "+this.lossfunc_s),console.log("     Current epoch: "+this.epoch),console.log("     Latest loss: "+this.loss)}else{if(e=console.log,void 0!==t.weights&&(i=t.weights),void 0!==t.gradients&&(r=t.gradients),void 0!==t.struct&&(s=t.struct),void 0!==t.misc&&(o=t.misc),void 0!==t.table&&(n=t.table),void 0!==t.details&&!0===t.details&&(s=t.details,r=t.details,o=t.details,i=t.details),s){console.log("Rann model:"),console.log("Layers:");for(let t=0;t<this.arch.length;t++)0!==t&&t!==this.arch.length-1?console.log("     hidden layer: "+this.arch[t]+"   ("+this.actname+")"):0===t?console.log("     Input layer: "+this.arch[t]):t===this.arch.length-1&&console.log("     output layer: "+this.arch[t]+"   ("+this.o_actname+")")}if(o&&(console.log("Other values"),console.log("     Learning rate: "+this.lr),console.log("     Loss function: "+this.lossfunc_s),console.log("     Current epoch: "+this.epoch),console.log("     Latest loss: "+this.loss)),o&&i&&console.log(""),i){let t,i,r;n?(e=console.table,t=this.U.matrix,i=this.W.matrix,r=this.V.matrix):(e=console.log,t=this.U,i=this.W,r=this.V),console.log("U: input to hidden weights"),e(t),console.log("W: shared hidden weights"),e(i),console.log("V: hidden to output weights"),e(r)}if(i&&r&&console.log(""),r){let t,i,r;n?(e=console.table,t=this.dU.matrix,i=this.dW.matrix,r=this.dV.matrix):(e=console.log,t=this.dU,i=this.dW,r=this.dV),console.log("Gradients of U:"),e(t),console.log("Gradients of W:"),e(i),console.log("Gradients of V:"),e(r)}}},Rann.prototype.makeWeights=function(t,e){if(void 0!==t||void 0!==e)return this.U.randomize(t,e),this.V.randomize(t,e),void this.W.randomize(t,e);DannError.error("Must specify minimum and maximum values for weights","Rann.prototype.makeWeights")},Rann.prototype.normalizeSequence=function(t,e){if(void 0!==e&&!0===e){let e=[];for(let i=0;i<t.length;i++)e=e.concat(t[i]);let i=Math.max.apply(1,e);this.largestSequenceValue<i&&(this.largestSequenceValue=i)}let i=[],r=t[0].length;for(let e=0;e<t.length;e++){i[e]=[];for(let s=0;s<r;s++)i[e].push(t[e][s]/this.largestSequenceValue)}return i},Rann.numToOutput=function(t){let e=Rann.ascii(),i=[];for(let e=0;e<t.length;e++)i.push(Math.round(t[e]));let r=i.toString().replace(/,/gi,"");return e[parseInt(r,2)]},Rann.prototype.outputActivation=function(t){if(void 0===activations[t]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.outputActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.outputActivation");this.o_actname=t;let e=Layer.stringTofunc(this.o_actname);this.o_actfunc=e.func,this.o_actfunc_d=e.func_d},Rann.prototype.setActivation=function(t){if(void 0===activations[t]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.setActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Rann.prototype.setActivation");this.actname=t;let e=Layer.stringTofunc(this.actname);this.actfunc=e.func,this.actfunc_d=e.func_d},Rann.prototype.setLossFunction=function(t){if(void 0===lossfuncs[t])return"string"==typeof t?void DannError.error("'"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default.","Rann.prototype.setLossFunction"):void DannError.error("Did not detect string value, as a result, the loss function is set to 'mse' by default.","Rann.prototype.setLossFunction");this.lossfunc_s=t,this.lossfunc=lossfuncs[t]},Rann.prototype.toJSON=function(){let t=JSON.stringify(this.arch),e=JSON.stringify(this.U.matrix),i=JSON.stringify(this.V.matrix),r=JSON.stringify(this.W.matrix),s=JSON.stringify(this.dU.matrix),o=JSON.stringify(this.dV.matrix),n=JSON.stringify(this.dW.matrix),a=JSON.stringify(this.dU_t.matrix),l=JSON.stringify(this.dV_t.matrix),h=JSON.stringify(this.dW_t.matrix),u=JSON.stringify(this.dU_i.matrix),c=JSON.stringify(this.dW_i.matrix),f=JSON.stringify(this.layers);return{i:this.i,h:this.h,o:this.o,act:this.actname,act_o:this.o_actname,lsv:this.largestSequenceValue,trun:this.truncate,loss:this.loss,e:this.epoch,lf:this.lossfunc_s,lr:this.lr,arch:t,layers:f,U:e,V:i,W:r,dU:s,dV:o,dW:n,dU_t:a,dV_t:l,dW_t:h,dU_i:u,dW_i:c}},Rann.prototype.train=function(t,e){let i=!1;if(void 0!==e&&void 0!==e.log&&(i=e.log),this.validateSequences(t)){"string"==typeof t[0]&&(t=Rann.inputToNum(t)),this.normalize&&(t=this.normalizeSequence(t,!0));let e=Object.assign([],t),r=e.length-1;for(let t=0;t<r;t++){let t=e.splice(e.length-1,1);this.trainSequence(e,t[0])}i&&console.log("Loss: ",this.loss)}else DannError.error("Input sequences length must equal the number of input neurons the Rann model has","Rann.prototype.train")},Rann.prototype.trainSequence=function(t,e){if(this.validateSequences(t)){let i,r,s=Matrix.fromArray(e);for(let o=0;o<t.length;o++){this.previous=new Matrix(this.h,1),r=t[o],i=r.length,this.layers=[],this.dU=new Matrix(this.h,this.i),this.dV=new Matrix(this.o,this.h),this.dW=new Matrix(this.h,this.h),this.dU_t=new Matrix(this.h,this.i),this.dV_t=new Matrix(this.o,this.h),this.dW_t=new Matrix(this.h,this.h),this.dU_i=new Matrix(this.h,this.i),this.dW_i=new Matrix(this.h,this.h);for(let t=0;t<i;t++){new_input=new Matrix(i,1),new_input.matrix[t][0]=r[t],this.mulu=Matrix.mult(this.U,new_input),this.mulw=Matrix.mult(this.W,this.previous);let e=Matrix.add(this.mulw,this.mulu);this.sum=e;let s=Matrix.map(e,this.actfunc);this.mulv=Matrix.mult(this.V,s),this.layers.push({current:s,previous:this.previous}),this.previous=s}this.dmulv=Matrix.sub(this.mulv,s),this.loss=this.lossfunc(Matrix.toArray(this.mulv),e)}for(let t=0;t<i;t++){this.dV_t=Matrix.mult(this.dmulv,Matrix.transpose(this.layers[t].current));let e=Matrix.mult(Matrix.transpose(this.V),this.dmulv),s=this.sum,o=this.sum,n=new Matrix(s.rows,s.cols);n.initiate(1);let a=Matrix.sub(n,o),l=s.mult(e),h=a.mult(l),u=new Matrix(this.mulw.rows,this.mulw.cols);u.initiate(1),this.dmulw=h.mult(u);let c=Math.max(-1,t-this.truncate-1);for(let e=t-1;e>c;e-=1){let e=new Matrix(this.mulu.rows,this.mulu.cols);e.initiate(1),this.dmulu=h.mult(e),this.dW_i=Matrix.mult(this.W,this.layers[t].previous);let s=new Matrix(i,1);s.matrix[t][0]=r[t],this.dU_i=Matrix.mult(this.U,s),this.dU_t=Matrix.addColumn(this.dU_t,this.dU_i),this.dW_t=Matrix.addColumn(this.dW_t,this.dW_i)}this.dV.add(this.dV_t),this.dU.add(this.dU_t),this.dW.add(this.dW_t)}return this.clipGradients(-10,10),this.U.sub(this.dU.mult(this.lr)),this.V.sub(this.dV.mult(this.lr)),void this.W.sub(this.dW.mult(this.lr))}DannError.error("Input sequences length must equal the number of input neurons the Rann model has","Rann.prototype.trainSequence")},Rann.prototype.unNormalizeSequence=function(t){let e=[];for(let i=0;i<t.length;i++){e[i]=[];for(let r=0;r<t[0].length;r++)e[i].push(t[i][r]*this.largestSequenceValue)}return e},Rann.prototype.validateSequences=function(t){for(let e=0;e<t.length;e++)if(t[e].length!==this.i)return!1;return!0},isBrowser||(module.exports={dann:Dann,rann:Rann,layer:Layer,matrix:Matrix,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs,xor:XOR,makeXOR:makeXOR,makeBinary:makeBinary,makeSinWave:makeSinWave,add:Add});